diff --git a/python/langsmith/_internal/_otel_utils.py b/python/langsmith/_internal/_otel_utils.py
new file mode 100644
index 00000000..c59b6aac
--- /dev/null
+++ b/python/langsmith/_internal/_otel_utils.py
@@ -0,0 +1,31 @@
+from __future__ import annotations
+
+from uuid import UUID
+
+
+def get_otel_trace_id_from_uuid(uuid_val: UUID) -> int:
+    """Get OpenTelemetry trace ID as integer from UUID.
+
+    Args:
+        uuid_val: The UUID to convert.
+
+    Returns:
+        Integer representation of the trace ID.
+    """
+    trace_id_hex = uuid_val.hex
+    return int(trace_id_hex, 16)
+
+
+def get_otel_span_id_from_uuid(uuid_val: UUID) -> int:
+    """Get OpenTelemetry span ID as integer from UUID.
+
+    Args:
+        uuid_val: The UUID to convert.
+
+    Returns:
+        Integer representation of the span ID.
+    """
+    uuid_bytes = uuid_val.bytes
+    span_id_bytes = uuid_bytes[:8]
+    span_id_hex = span_id_bytes.hex()
+    return int(span_id_hex, 16)
diff --git a/python/langsmith/_internal/otel/_otel_exporter.py b/python/langsmith/_internal/otel/_otel_exporter.py
index 01b4d4dc..23277b23 100644
--- a/python/langsmith/_internal/otel/_otel_exporter.py
+++ b/python/langsmith/_internal/otel/_otel_exporter.py
@@ -13,6 +13,10 @@ from langsmith._internal import _orjson
 from langsmith._internal._operations import (
     SerializedRunOperation,
 )
+from langsmith._internal._otel_utils import (
+    get_otel_span_id_from_uuid,
+    get_otel_trace_id_from_uuid,
+)
 
 HAS_OTEL = False
 try:
@@ -20,7 +24,11 @@ try:
         from opentelemetry import trace  # type: ignore[import]
         from opentelemetry.context.context import Context  # type: ignore[import]
         from opentelemetry.trace import (  # type: ignore[import]
+            NonRecordingSpan,
             Span,
+            SpanContext,
+            TraceFlags,
+            TraceState,
             set_span_in_context,
         )
 
@@ -183,18 +191,41 @@ class OTELExporter:
             end_time = run_info.get("end_time")
             end_time_utc_nano = self._as_utc_nano(end_time)
 
-            # Start the span
+            # Create deterministic trace and span IDs to match user OpenTelemetry spans
+            trace_id_int = get_otel_trace_id_from_uuid(op.trace_id)
+            span_id_int = get_otel_span_id_from_uuid(op.id)
+
+            # Create SpanContext with deterministic IDs
+            span_context = SpanContext(
+                trace_id=trace_id_int,
+                span_id=span_id_int,
+                is_remote=False,
+                trace_flags=TraceFlags(TraceFlags.SAMPLED),
+                trace_state=TraceState(),
+            )
+
+            # Create NonRecordingSpan for context setting
+            non_recording_span = NonRecordingSpan(span_context)
+            deterministic_context = set_span_in_context(non_recording_span)
+
+            # Start the span with appropriate context
             parent_run_id = run_info.get("parent_run_id")
             if parent_run_id is not None and uuid.UUID(parent_run_id) in self._spans:
+                # Use the parent span context
                 span = self._tracer.start_span(
                     run_info.get("name"),
                     context=set_span_in_context(self._spans[uuid.UUID(parent_run_id)]),
                     start_time=start_time_utc_nano,
                 )
             else:
+                # For root spans, check if there's an existing OpenTelemetry context
+                # If so, inherit from it; otherwise use our deterministic context
+                current_context = (
+                    otel_context if otel_context else deterministic_context
+                )
                 span = self._tracer.start_span(
                     run_info.get("name"),
-                    context=otel_context,
+                    context=current_context,
                     start_time=start_time_utc_nano,
                 )
 
diff --git a/python/langsmith/run_helpers.py b/python/langsmith/run_helpers.py
index 80a40a92..062e1d4b 100644
--- a/python/langsmith/run_helpers.py
+++ b/python/langsmith/run_helpers.py
@@ -75,6 +75,8 @@ _CONTEXT_KEYS: dict[str, contextvars.ContextVar] = {
 
 _EXCLUDED_FRAME_FNAME = "langsmith/run_helpers.py"
 
+_OTEL_AVAILABLE: Optional[bool] = None
+
 
 def get_current_run_tree() -> Optional[run_trees.RunTree]:
     """Get the current run tree."""
@@ -533,17 +535,38 @@ def traceable(
                 accepts_context = aitertools.asyncio_accepts_context()
                 if func_accepts_parent_run:
                     kwargs["run_tree"] = run_container["new_run"]
-                fr_coro = func(*args, **kwargs)
-                if accepts_context:
-                    function_result = await asyncio.create_task(  # type: ignore[call-arg]
-                        fr_coro, context=run_container["context"]
-                    )
+
+                otel_context_manager = _maybe_create_otel_context(
+                    run_container["new_run"]
+                )
+                if otel_context_manager:
+
+                    async def run_with_otel_context():
+                        with otel_context_manager:
+                            return await func(*args, **kwargs)
+
+                    if accepts_context:
+                        function_result = await asyncio.create_task(  # type: ignore[call-arg]
+                            run_with_otel_context(), context=run_container["context"]
+                        )
+                    else:
+                        # Python < 3.11
+                        with tracing_context(
+                            **get_tracing_context(run_container["context"])
+                        ):
+                            function_result = await run_with_otel_context()
                 else:
-                    # Python < 3.11
-                    with tracing_context(
-                        **get_tracing_context(run_container["context"])
-                    ):
-                        function_result = await fr_coro
+                    fr_coro = func(*args, **kwargs)
+                    if accepts_context:
+                        function_result = await asyncio.create_task(  # type: ignore[call-arg]
+                            fr_coro, context=run_container["context"]
+                        )
+                    else:
+                        # Python < 3.11
+                        with tracing_context(
+                            **get_tracing_context(run_container["context"])
+                        ):
+                            function_result = await fr_coro
             except BaseException as e:
                 # shield from cancellation, given we're catching all exceptions
                 _cleanup_traceback(e)
@@ -577,6 +600,11 @@ def traceable(
                     # TODO: Nesting is ambiguous if a nested traceable function is only
                     # called mid-generation. Need to explicitly accept run_tree to get
                     # around this.
+
+                otel_context_manager = _maybe_create_otel_context(
+                    run_container["new_run"]
+                )
+
                 async_gen_result = func(*args, **kwargs)
                 # Can't iterate through if it's a coroutine
                 accepts_context = aitertools.asyncio_accepts_context()
@@ -603,6 +631,7 @@ def traceable(
                     accepts_context=accepts_context,
                     results=results,
                     process_chunk=container_input.get("process_chunk"),
+                    otel_context_manager=otel_context_manager,
                 ):
                     yield item
             except BaseException as e:
@@ -644,7 +673,23 @@ def traceable(
             try:
                 if func_accepts_parent_run:
                     kwargs["run_tree"] = run_container["new_run"]
-                function_result = run_container["context"].run(func, *args, **kwargs)
+
+                otel_context_manager = _maybe_create_otel_context(
+                    run_container["new_run"]
+                )
+                if otel_context_manager:
+
+                    def run_with_otel_context():
+                        with otel_context_manager:
+                            return func(*args, **kwargs)
+
+                    function_result = run_container["context"].run(
+                        run_with_otel_context
+                    )
+                else:
+                    function_result = run_container["context"].run(
+                        func, *args, **kwargs
+                    )
             except BaseException as e:
                 _cleanup_traceback(e)
                 _on_run_end(run_container, error=e)
@@ -674,14 +719,20 @@ def traceable(
             try:
                 if func_accepts_parent_run:
                     kwargs["run_tree"] = run_container["new_run"]
+
                 generator_result = run_container["context"].run(func, *args, **kwargs)
 
+                otel_context_manager = _maybe_create_otel_context(
+                    run_container["new_run"]
+                )
+
                 function_return = yield from _process_iterator(
                     generator_result,
                     run_container,
                     is_llm_run=run_type == "llm",
                     results=results,
                     process_chunk=container_input.get("process_chunk"),
+                    otel_context_manager=otel_context_manager,
                 )
 
                 if function_return is not None:
@@ -1609,10 +1660,25 @@ def _process_iterator(
     # Results is mutated
     results: list[Any],
     process_chunk: Optional[Callable],
+    otel_context_manager: Optional[Any] = None,
 ) -> Generator[T, None, Any]:
     try:
         while True:
-            item: T = run_container["context"].run(next, generator)  # type: ignore[arg-type]
+            if otel_context_manager:
+                # Create a fresh context manager for each iteration
+                def next_with_otel_context():
+                    # Get the run_tree from run_container to create a fresh context
+                    run_tree = run_container.get("new_run")
+                    if run_tree:
+                        fresh_otel_context = _maybe_create_otel_context(run_tree)
+                        if fresh_otel_context:
+                            with fresh_otel_context:
+                                return next(generator)
+                    return next(generator)
+
+                item: T = run_container["context"].run(next_with_otel_context)  # type: ignore[arg-type]
+            else:
+                item = run_container["context"].run(next, generator)  # type: ignore[arg-type]
             if process_chunk:
                 traced_item = process_chunk(item)
             else:
@@ -1646,18 +1712,45 @@ async def _process_async_iterator(
     accepts_context: bool,
     results: list[Any],
     process_chunk: Optional[Callable],
+    otel_context_manager: Optional[Any] = None,
 ) -> AsyncGenerator[T, None]:
     try:
         while True:
-            if accepts_context:
-                item = await asyncio.create_task(  # type: ignore[call-arg, var-annotated]
-                    aitertools.py_anext(generator),  # type: ignore[arg-type]
-                    context=run_container["context"],
-                )
+            if otel_context_manager:
+                # Create a fresh context manager for each iteration
+                async def anext_with_otel_context():
+                    # Get the run_tree from run_container to create a fresh context
+                    run_tree = run_container.get("new_run")
+                    if run_tree:
+                        fresh_otel_context = _maybe_create_otel_context(run_tree)
+                        if fresh_otel_context:
+                            with fresh_otel_context:
+                                return await aitertools.py_anext(generator)
+                    return await aitertools.py_anext(generator)
+
+                if accepts_context:
+                    item = await asyncio.create_task(  # type: ignore[call-arg, var-annotated]
+                        anext_with_otel_context(),
+                        context=run_container["context"],
+                    )
+                else:
+                    # Python < 3.11
+                    with tracing_context(
+                        **get_tracing_context(run_container["context"])
+                    ):
+                        item = await anext_with_otel_context()
             else:
-                # Python < 3.11
-                with tracing_context(**get_tracing_context(run_container["context"])):
-                    item = await aitertools.py_anext(generator)
+                if accepts_context:
+                    item = await asyncio.create_task(  # type: ignore[call-arg, var-annotated]
+                        aitertools.py_anext(generator),  # type: ignore[arg-type]
+                        context=run_container["context"],
+                    )
+                else:
+                    # Python < 3.11
+                    with tracing_context(
+                        **get_tracing_context(run_container["context"])
+                    ):
+                        item = await aitertools.py_anext(generator)
             if process_chunk:
                 traced_item = process_chunk(item)
             else:
@@ -1876,3 +1969,59 @@ def _cleanup_traceback(e: BaseException):
         ):
             tb_ = tb_.tb_next
         e.__traceback__ = tb_
+
+
+def _is_otel_available() -> bool:
+    """Cache for otel import check."""
+    global _OTEL_AVAILABLE
+    if _OTEL_AVAILABLE is None:
+        try:
+            import opentelemetry.trace  # noqa: F401
+
+            _OTEL_AVAILABLE = True
+        except ImportError:
+            _OTEL_AVAILABLE = False
+    return _OTEL_AVAILABLE
+
+
+def _maybe_create_otel_context(run_tree: Optional[run_trees.RunTree]):
+    """Create OpenTelemetry context manager if OTEL is enabled and available.
+
+    Args:
+        run_tree: The current run tree.
+
+    Returns:
+        Context manager for use_span or None if not available.
+    """
+    if not run_tree or not utils.is_truish(utils.get_env_var("OTEL_ENABLED")):
+        return None
+
+    if not _is_otel_available():
+        return None
+
+    from opentelemetry.trace import (  # type: ignore[import]
+        NonRecordingSpan,
+        SpanContext,
+        TraceFlags,
+        TraceState,
+        use_span,
+    )
+
+    from langsmith._internal._otel_utils import (
+        get_otel_span_id_from_uuid,
+        get_otel_trace_id_from_uuid,
+    )
+
+    trace_id = get_otel_trace_id_from_uuid(run_tree.trace_id)
+    span_id = get_otel_span_id_from_uuid(run_tree.id)
+
+    span_context = SpanContext(
+        trace_id=trace_id,
+        span_id=span_id,
+        is_remote=False,
+        trace_flags=TraceFlags(TraceFlags.SAMPLED),
+        trace_state=TraceState(),
+    )
+
+    non_recording_span = NonRecordingSpan(span_context)
+    return use_span(non_recording_span)
diff --git a/python/poetry.lock b/python/poetry.lock
index 00109ee9..a2dd6726 100644
--- a/python/poetry.lock
+++ b/python/poetry.lock
@@ -1,4 +1,4 @@
-# This file is automatically @generated by Poetry 1.8.5 and should not be changed by hand.
+# This file is automatically @generated by Poetry 2.1.3 and should not be changed by hand.
 
 [[package]]
 name = "annotated-types"
@@ -6,6 +6,7 @@ version = "0.7.0"
 description = "Reusable constraint types to use with typing.Annotated"
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "annotated_types-0.7.0-py3-none-any.whl", hash = "sha256:1f02e8b43a8fbbc3f3e0d4f0f4bfc8131bcb4eebe8849b8e5c773f3a1c582a53"},
     {file = "annotated_types-0.7.0.tar.gz", hash = "sha256:aff07c09a53a08bc8cfccb9c85b05f1aa9a2a6f23728d790723543408344ce89"},
@@ -17,6 +18,7 @@ version = "0.45.2"
 description = "The official Python library for the anthropic API"
 optional = false
 python-versions = ">=3.8"
+groups = ["test"]
 files = [
     {file = "anthropic-0.45.2-py3-none-any.whl", hash = "sha256:ecd746f7274451dfcb7e1180571ead624c7e1195d1d46cb7c70143d2aedb4d35"},
     {file = "anthropic-0.45.2.tar.gz", hash = "sha256:32a18b9ecd12c91b2be4cae6ca2ab46a06937b5aa01b21308d97a6d29794fb5e"},
@@ -41,6 +43,7 @@ version = "4.9.0"
 description = "High level compatibility layer for multiple asynchronous event loop implementations"
 optional = false
 python-versions = ">=3.9"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "anyio-4.9.0-py3-none-any.whl", hash = "sha256:9f76d541cad6e36af7beb62e978876f3b41e3e04f2c1fbf0884604c0a9c4d93c"},
     {file = "anyio-4.9.0.tar.gz", hash = "sha256:673c0c244e15788651a4ff38710fea9675823028a6f08a5eda409e0c9840a028"},
@@ -54,7 +57,7 @@ typing_extensions = {version = ">=4.5", markers = "python_version < \"3.13\""}
 
 [package.extras]
 doc = ["Sphinx (>=8.2,<9.0)", "packaging", "sphinx-autodoc-typehints (>=1.2.0)", "sphinx_rtd_theme"]
-test = ["anyio[trio]", "blockbuster (>=1.5.23)", "coverage[toml] (>=7)", "exceptiongroup (>=1.2.0)", "hypothesis (>=4.0)", "psutil (>=5.9)", "pytest (>=7.0)", "trustme", "truststore (>=0.9.1)", "uvloop (>=0.21)"]
+test = ["anyio[trio]", "blockbuster (>=1.5.23)", "coverage[toml] (>=7)", "exceptiongroup (>=1.2.0)", "hypothesis (>=4.0)", "psutil (>=5.9)", "pytest (>=7.0)", "trustme", "truststore (>=0.9.1) ; python_version >= \"3.10\"", "uvloop (>=0.21) ; platform_python_implementation == \"CPython\" and platform_system != \"Windows\" and python_version < \"3.14\""]
 trio = ["trio (>=0.26.1)"]
 
 [[package]]
@@ -63,18 +66,19 @@ version = "25.3.0"
 description = "Classes Without Boilerplate"
 optional = false
 python-versions = ">=3.8"
+groups = ["dev"]
 files = [
     {file = "attrs-25.3.0-py3-none-any.whl", hash = "sha256:427318ce031701fea540783410126f03899a97ffc6f61596ad581ac2e40e3bc3"},
     {file = "attrs-25.3.0.tar.gz", hash = "sha256:75d7cefc7fb576747b2c81b4442d4d4a1ce0900973527c011d1030fd3bf4af1b"},
 ]
 
 [package.extras]
-benchmark = ["cloudpickle", "hypothesis", "mypy (>=1.11.1)", "pympler", "pytest (>=4.3.0)", "pytest-codspeed", "pytest-mypy-plugins", "pytest-xdist[psutil]"]
-cov = ["cloudpickle", "coverage[toml] (>=5.3)", "hypothesis", "mypy (>=1.11.1)", "pympler", "pytest (>=4.3.0)", "pytest-mypy-plugins", "pytest-xdist[psutil]"]
-dev = ["cloudpickle", "hypothesis", "mypy (>=1.11.1)", "pre-commit-uv", "pympler", "pytest (>=4.3.0)", "pytest-mypy-plugins", "pytest-xdist[psutil]"]
+benchmark = ["cloudpickle ; platform_python_implementation == \"CPython\"", "hypothesis", "mypy (>=1.11.1) ; platform_python_implementation == \"CPython\" and python_version >= \"3.10\"", "pympler", "pytest (>=4.3.0)", "pytest-codspeed", "pytest-mypy-plugins ; platform_python_implementation == \"CPython\" and python_version >= \"3.10\"", "pytest-xdist[psutil]"]
+cov = ["cloudpickle ; platform_python_implementation == \"CPython\"", "coverage[toml] (>=5.3)", "hypothesis", "mypy (>=1.11.1) ; platform_python_implementation == \"CPython\" and python_version >= \"3.10\"", "pympler", "pytest (>=4.3.0)", "pytest-mypy-plugins ; platform_python_implementation == \"CPython\" and python_version >= \"3.10\"", "pytest-xdist[psutil]"]
+dev = ["cloudpickle ; platform_python_implementation == \"CPython\"", "hypothesis", "mypy (>=1.11.1) ; platform_python_implementation == \"CPython\" and python_version >= \"3.10\"", "pre-commit-uv", "pympler", "pytest (>=4.3.0)", "pytest-mypy-plugins ; platform_python_implementation == \"CPython\" and python_version >= \"3.10\"", "pytest-xdist[psutil]"]
 docs = ["cogapp", "furo", "myst-parser", "sphinx", "sphinx-notfound-page", "sphinxcontrib-towncrier", "towncrier"]
-tests = ["cloudpickle", "hypothesis", "mypy (>=1.11.1)", "pympler", "pytest (>=4.3.0)", "pytest-mypy-plugins", "pytest-xdist[psutil]"]
-tests-mypy = ["mypy (>=1.11.1)", "pytest-mypy-plugins"]
+tests = ["cloudpickle ; platform_python_implementation == \"CPython\"", "hypothesis", "mypy (>=1.11.1) ; platform_python_implementation == \"CPython\" and python_version >= \"3.10\"", "pympler", "pytest (>=4.3.0)", "pytest-mypy-plugins ; platform_python_implementation == \"CPython\" and python_version >= \"3.10\"", "pytest-xdist[psutil]"]
+tests-mypy = ["mypy (>=1.11.1) ; platform_python_implementation == \"CPython\" and python_version >= \"3.10\"", "pytest-mypy-plugins ; platform_python_implementation == \"CPython\" and python_version >= \"3.10\""]
 
 [[package]]
 name = "black"
@@ -82,6 +86,7 @@ version = "24.10.0"
 description = "The uncompromising code formatter."
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "black-24.10.0-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:e6668650ea4b685440857138e5fe40cde4d652633b1bdffc62933d0db4ed9812"},
     {file = "black-24.10.0-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:1c536fcf674217e87b8cc3657b81809d3c085d7bf3ef262ead700da345bfa6ea"},
@@ -128,6 +133,7 @@ version = "2025.1.31"
 description = "Python package for providing Mozilla's CA Bundle."
 optional = false
 python-versions = ">=3.6"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "certifi-2025.1.31-py3-none-any.whl", hash = "sha256:ca78db4565a652026a4db2bcdf68f2fb589ea80d0be70e03929ed730746b84fe"},
     {file = "certifi-2025.1.31.tar.gz", hash = "sha256:3d5da6925056f6f18f119200434a4780a94263f10d1c21d032a6f6b2baa20651"},
@@ -139,6 +145,8 @@ version = "1.17.1"
 description = "Foreign Function Interface for Python calling C code."
 optional = false
 python-versions = ">=3.8"
+groups = ["main"]
+markers = "platform_python_implementation == \"PyPy\""
 files = [
     {file = "cffi-1.17.1-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:df8b1c11f177bc2313ec4b2d46baec87a5f3e71fc8b45dab2ee7cae86d9aba14"},
     {file = "cffi-1.17.1-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:8f2cdc858323644ab277e9bb925ad72ae0e67f69e804f4898c070998d50b1a67"},
@@ -218,6 +226,7 @@ version = "3.4.1"
 description = "The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet."
 optional = false
 python-versions = ">=3.7"
+groups = ["main", "dev"]
 files = [
     {file = "charset_normalizer-3.4.1-cp310-cp310-macosx_10_9_universal2.whl", hash = "sha256:91b36a978b5ae0ee86c394f5a54d6ef44db1de0815eb43de826d41d21e4af3de"},
     {file = "charset_normalizer-3.4.1-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:7461baadb4dc00fd9e0acbe254e3d7d2112e7f92ced2adc96e54ef6501c5f176"},
@@ -319,6 +328,7 @@ version = "8.1.8"
 description = "Composable command line interface toolkit"
 optional = false
 python-versions = ">=3.7"
+groups = ["main", "dev"]
 files = [
     {file = "click-8.1.8-py3-none-any.whl", hash = "sha256:63c132bbbed01578a06712a2d1f497bb62d9c1c0d329b7903a866228027263b2"},
     {file = "click-8.1.8.tar.gz", hash = "sha256:ed53c9d8990d83c2a27deae68e4ee337473f6330c040a31d4225c9574d16096a"},
@@ -333,10 +343,12 @@ version = "0.4.6"
 description = "Cross-platform colored terminal text."
 optional = false
 python-versions = "!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*,!=3.6.*,>=2.7"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "colorama-0.4.6-py2.py3-none-any.whl", hash = "sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6"},
     {file = "colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44"},
 ]
+markers = {main = "sys_platform == \"win32\" or extra == \"openai-agents\" or platform_system == \"Windows\"", dev = "sys_platform == \"win32\" or platform_system == \"Windows\"", lint = "platform_system == \"Windows\"", test = "sys_platform == \"win32\" and python_version < \"4.0\""}
 
 [[package]]
 name = "coverage"
@@ -344,6 +356,7 @@ version = "7.8.0"
 description = "Code coverage measurement for Python"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "coverage-7.8.0-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:2931f66991175369859b5fd58529cd4b73582461877ecfd859b6549869287ffe"},
     {file = "coverage-7.8.0-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:52a523153c568d2c0ef8826f6cc23031dc86cffb8c6aeab92c4ff776e7951b28"},
@@ -414,7 +427,7 @@ files = [
 tomli = {version = "*", optional = true, markers = "python_full_version <= \"3.11.0a6\" and extra == \"toml\""}
 
 [package.extras]
-toml = ["tomli"]
+toml = ["tomli ; python_full_version <= \"3.11.0a6\""]
 
 [[package]]
 name = "dataclasses-json"
@@ -422,6 +435,8 @@ version = "0.6.7"
 description = "Easily serialize dataclasses to and from JSON."
 optional = false
 python-versions = "<4.0,>=3.7"
+groups = ["dev"]
+markers = "python_version < \"4.0\""
 files = [
     {file = "dataclasses_json-0.6.7-py3-none-any.whl", hash = "sha256:0dbf33f26c8d5305befd61b39d2b3414e8a407bedc2834dea9b8d642666fb40a"},
     {file = "dataclasses_json-0.6.7.tar.gz", hash = "sha256:b6b3e528266ea45b9535223bc53ca645f5208833c29229e847b3f26a1cc55fc0"},
@@ -431,29 +446,13 @@ files = [
 marshmallow = ">=3.18.0,<4.0.0"
 typing-inspect = ">=0.4.0,<1"
 
-[[package]]
-name = "deprecated"
-version = "1.2.18"
-description = "Python @deprecated decorator to deprecate old python classes, functions or methods."
-optional = true
-python-versions = "!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,>=2.7"
-files = [
-    {file = "Deprecated-1.2.18-py2.py3-none-any.whl", hash = "sha256:bd5011788200372a32418f888e326a09ff80d0214bd961147cfed01b5c018eec"},
-    {file = "deprecated-1.2.18.tar.gz", hash = "sha256:422b6f6d859da6f2ef57857761bfb392480502a64c3028ca9bbe86085d72115d"},
-]
-
-[package.dependencies]
-wrapt = ">=1.10,<2"
-
-[package.extras]
-dev = ["PyTest", "PyTest-Cov", "bump2version (<1)", "setuptools", "tox"]
-
 [[package]]
 name = "distro"
 version = "1.9.0"
 description = "Distro - an OS platform information API"
 optional = false
 python-versions = ">=3.6"
+groups = ["main", "lint", "test"]
 files = [
     {file = "distro-1.9.0-py3-none-any.whl", hash = "sha256:7bffd925d65168f85027d8da9af6bddab658135b840670a223589bc0c8ef02b2"},
     {file = "distro-1.9.0.tar.gz", hash = "sha256:2fa77c6fd8940f116ee1d6b94a2f90b13b5ea8d019b98bc8bafdcabcdd9bdbed"},
@@ -465,6 +464,8 @@ version = "1.2.2"
 description = "Backport of PEP 654 (exception groups)"
 optional = false
 python-versions = ">=3.7"
+groups = ["main", "dev", "lint", "test"]
+markers = "python_version < \"3.11\""
 files = [
     {file = "exceptiongroup-1.2.2-py3-none-any.whl", hash = "sha256:3111b9d131c238bec2f8f516e123e14ba243563fb135d3fe885990585aa7795b"},
     {file = "exceptiongroup-1.2.2.tar.gz", hash = "sha256:47c2edf7c6738fafb49fd34290706d1a1a2f4d1c6df275526b62cbb4aa5393cc"},
@@ -479,6 +480,7 @@ version = "2.1.1"
 description = "execnet: rapid multi-Python deployment"
 optional = false
 python-versions = ">=3.8"
+groups = ["dev"]
 files = [
     {file = "execnet-2.1.1-py3-none-any.whl", hash = "sha256:26dee51f1b80cebd6d0ca8e74dd8745419761d3bef34163928cbebbdc4749fdc"},
     {file = "execnet-2.1.1.tar.gz", hash = "sha256:5189b52c6121c24feae288166ab41b32549c7e2348652736540b9e6e7d4e72e3"},
@@ -493,6 +495,7 @@ version = "0.115.12"
 description = "FastAPI framework, high performance, easy to learn, fast to code, ready for production"
 optional = false
 python-versions = ">=3.8"
+groups = ["dev"]
 files = [
     {file = "fastapi-0.115.12-py3-none-any.whl", hash = "sha256:e94613d6c05e27be7ffebdd6ea5f388112e5e430c8f7d6494a9d1d88d43e814d"},
     {file = "fastapi-0.115.12.tar.gz", hash = "sha256:1e2c2a2646905f9e83d32f04a3f86aff4a286669c6c950ca95b5fd68c2602681"},
@@ -513,6 +516,7 @@ version = "1.5.1"
 description = "Let your Python tests travel through time"
 optional = false
 python-versions = ">=3.7"
+groups = ["dev"]
 files = [
     {file = "freezegun-1.5.1-py3-none-any.whl", hash = "sha256:bf111d7138a8abe55ab48a71755673dbaa4ab87f4cff5634a4442dfec34c15f1"},
     {file = "freezegun-1.5.1.tar.gz", hash = "sha256:b29dedfcda6d5e8e083ce71b2b542753ad48cfec44037b3fc79702e2980a89e9"},
@@ -525,8 +529,9 @@ python-dateutil = ">=2.7"
 name = "googleapis-common-protos"
 version = "1.69.2"
 description = "Common protobufs used in Google APIs"
-optional = true
+optional = false
 python-versions = ">=3.7"
+groups = ["main", "dev"]
 files = [
     {file = "googleapis_common_protos-1.69.2-py3-none-any.whl", hash = "sha256:0b30452ff9c7a27d80bfc5718954063e8ab53dd3697093d3bc99581f5fd24212"},
     {file = "googleapis_common_protos-1.69.2.tar.gz", hash = "sha256:3e1b904a27a33c821b4b749fd31d334c0c9c30e6113023d495e48979a3dc9c5f"},
@@ -544,6 +549,8 @@ version = "1.7.1"
 description = "Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API."
 optional = true
 python-versions = ">=3.9"
+groups = ["main"]
+markers = "extra == \"openai-agents\""
 files = [
     {file = "griffe-1.7.1-py3-none-any.whl", hash = "sha256:37a7f15233937d723ddc969fa4117fdd03988885c16938dc43bccdfe8fa4d02d"},
     {file = "griffe-1.7.1.tar.gz", hash = "sha256:464730d0e95d0afd038e699a5f7276d7438d0712db0c489a17e761f70e011507"},
@@ -558,6 +565,7 @@ version = "0.16.0"
 description = "A pure-Python, bring-your-own-I/O implementation of HTTP/1.1"
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "h11-0.16.0-py3-none-any.whl", hash = "sha256:63cf8bbe7522de3bf65932fda1d9c2772064ffb3dae62d55932da54b31cb6c86"},
     {file = "h11-0.16.0.tar.gz", hash = "sha256:4e35b956cf45792e4caa5885e69fba00bdbc6ffafbfa020300e549b208ee5ff1"},
@@ -569,6 +577,7 @@ version = "1.0.9"
 description = "A minimal low-level HTTP client."
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "httpcore-1.0.9-py3-none-any.whl", hash = "sha256:2d400746a40668fc9dec9810239072b40b4484b640a8c38fd654a024c7a1bf55"},
     {file = "httpcore-1.0.9.tar.gz", hash = "sha256:6e34463af53fd2ab5d807f399a9b45ea31c3dfa2276f15a2c3f00afff6e176e8"},
@@ -590,6 +599,7 @@ version = "0.27.2"
 description = "The next generation HTTP client."
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "httpx-0.27.2-py3-none-any.whl", hash = "sha256:7bb2708e112d8fdd7829cd4243970f0c223274051cb35ee80c03301ee29a3df0"},
     {file = "httpx-0.27.2.tar.gz", hash = "sha256:f7c2be1d2f3c3c3160d441802406b206c2b76f5947b11115e6df10c6c65e66c2"},
@@ -603,7 +613,7 @@ idna = "*"
 sniffio = "*"
 
 [package.extras]
-brotli = ["brotli", "brotlicffi"]
+brotli = ["brotli ; platform_python_implementation == \"CPython\"", "brotlicffi ; platform_python_implementation != \"CPython\""]
 cli = ["click (==8.*)", "pygments (==2.*)", "rich (>=10,<14)"]
 http2 = ["h2 (>=3,<5)"]
 socks = ["socksio (==1.*)"]
@@ -615,6 +625,8 @@ version = "0.4.0"
 description = "Consume Server-Sent Event (SSE) messages with HTTPX."
 optional = true
 python-versions = ">=3.8"
+groups = ["main"]
+markers = "python_version >= \"3.10\" and extra == \"openai-agents\""
 files = [
     {file = "httpx-sse-0.4.0.tar.gz", hash = "sha256:1e81a3a3070ce322add1d3529ed42eb5f70817f45ed6ec915ab753f961139721"},
     {file = "httpx_sse-0.4.0-py3-none-any.whl", hash = "sha256:f329af6eae57eaa2bdfd962b42524764af68075ea87370a2de920af5341e318f"},
@@ -626,6 +638,7 @@ version = "3.10"
 description = "Internationalized Domain Names in Applications (IDNA)"
 optional = false
 python-versions = ">=3.6"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "idna-3.10-py3-none-any.whl", hash = "sha256:946d195a0d259cbba61165e88e65941f16e9b36ea6ddb97f00452bae8b1287d3"},
     {file = "idna-3.10.tar.gz", hash = "sha256:12f65c9b470abda6dc35cf8e63cc574b1c52b11df2c86030af0ac09b01b13ea9"},
@@ -638,8 +651,9 @@ all = ["flake8 (>=7.1.1)", "mypy (>=1.11.2)", "pytest (>=8.3.2)", "ruff (>=0.6.2
 name = "importlib-metadata"
 version = "8.6.1"
 description = "Read metadata from Python packages"
-optional = true
+optional = false
 python-versions = ">=3.9"
+groups = ["main", "dev"]
 files = [
     {file = "importlib_metadata-8.6.1-py3-none-any.whl", hash = "sha256:02a89390c1e15fdfdc0d7c6b25cb3e62650d0494005c97d6f148bf5b9787525e"},
     {file = "importlib_metadata-8.6.1.tar.gz", hash = "sha256:310b41d755445d74569f993ccfc22838295d9fe005425094fad953d7f15c8580"},
@@ -649,12 +663,12 @@ files = [
 zipp = ">=3.20"
 
 [package.extras]
-check = ["pytest-checkdocs (>=2.4)", "pytest-ruff (>=0.2.1)"]
+check = ["pytest-checkdocs (>=2.4)", "pytest-ruff (>=0.2.1) ; sys_platform != \"cygwin\""]
 cover = ["pytest-cov"]
 doc = ["furo", "jaraco.packaging (>=9.3)", "jaraco.tidelift (>=1.4)", "rst.linker (>=1.9)", "sphinx (>=3.5)", "sphinx-lint"]
 enabler = ["pytest-enabler (>=2.2)"]
 perf = ["ipython"]
-test = ["flufl.flake8", "importlib_resources (>=1.3)", "jaraco.test (>=5.4)", "packaging", "pyfakefs", "pytest (>=6,!=8.1.*)", "pytest-perf (>=0.9.2)"]
+test = ["flufl.flake8", "importlib_resources (>=1.3) ; python_version < \"3.9\"", "jaraco.test (>=5.4)", "packaging", "pyfakefs", "pytest (>=6,!=8.1.*)", "pytest-perf (>=0.9.2)"]
 type = ["pytest-mypy"]
 
 [[package]]
@@ -663,10 +677,12 @@ version = "2.1.0"
 description = "brain-dead simple config-ini parsing"
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev", "test"]
 files = [
     {file = "iniconfig-2.1.0-py3-none-any.whl", hash = "sha256:9deba5723312380e77435581c6bf4935c94cbfab9b1ed33ef8d238ea168eb760"},
     {file = "iniconfig-2.1.0.tar.gz", hash = "sha256:3abbd2e30b36733fee78f9c7f7308f2d0050e88f0087fd25c2645f63c773e1c7"},
 ]
+markers = {test = "python_version < \"4.0\""}
 
 [[package]]
 name = "jiter"
@@ -674,6 +690,7 @@ version = "0.9.0"
 description = "Fast iterable JSON parser."
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "lint", "test"]
 files = [
     {file = "jiter-0.9.0-cp310-cp310-macosx_10_12_x86_64.whl", hash = "sha256:816ec9b60fdfd1fec87da1d7ed46c66c44ffec37ab2ef7de5b147b2fce3fd5ad"},
     {file = "jiter-0.9.0-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:9b1d3086f8a3ee0194ecf2008cf81286a5c3e540d977fa038ff23576c023c0ea"},
@@ -759,6 +776,8 @@ version = "0.1.0rc5"
 description = ""
 optional = true
 python-versions = ">=3.9"
+groups = ["main"]
+markers = "extra == \"langsmith-pyo3\""
 files = [
     {file = "langsmith_pyo3-0.1.0rc5-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:670e5707f09e756e3b71f12a46f546826893158c2dde3250e212234e15ac8c70"},
     {file = "langsmith_pyo3-0.1.0rc5-cp310-cp310-manylinux_2_28_aarch64.whl", hash = "sha256:e0d2261c3f9ba07594c7450187604c4c4b1e10e3b3f4a4eb39587a495d6945e3"},
@@ -798,6 +817,7 @@ version = "3.0.0"
 description = "Python port of markdown-it. Markdown parsing, done right!"
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev"]
 files = [
     {file = "markdown-it-py-3.0.0.tar.gz", hash = "sha256:e3f60a94fa066dc52ec76661e37c851cb232d92f9886b15cb560aaada2df8feb"},
     {file = "markdown_it_py-3.0.0-py3-none-any.whl", hash = "sha256:355216845c60bd96232cd8d8c40e8f9765cc86f46880e43a8fd22dc1a1a8cab1"},
@@ -822,6 +842,8 @@ version = "3.26.1"
 description = "A lightweight library for converting complex datatypes to and from native Python datatypes."
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
+markers = "python_version < \"4.0\""
 files = [
     {file = "marshmallow-3.26.1-py3-none-any.whl", hash = "sha256:3350409f20a70a7e4e11a27661187b77cdcaeb20abca41c1454fe33636bea09c"},
     {file = "marshmallow-3.26.1.tar.gz", hash = "sha256:e6d8affb6cb61d39d26402096dc0aee12d5a26d490a121f118d2e81dc0719dc6"},
@@ -841,6 +863,8 @@ version = "1.6.0"
 description = "Model Context Protocol SDK"
 optional = true
 python-versions = ">=3.10"
+groups = ["main"]
+markers = "python_version >= \"3.10\" and extra == \"openai-agents\""
 files = [
     {file = "mcp-1.6.0-py3-none-any.whl", hash = "sha256:7bd24c6ea042dbec44c754f100984d186620d8b841ec30f1b19eda9b93a634d0"},
     {file = "mcp-1.6.0.tar.gz", hash = "sha256:d9324876de2c5637369f43161cd71eebfd803df5a95e46225cab8d280e366723"},
@@ -867,6 +891,7 @@ version = "0.1.2"
 description = "Markdown URL utilities"
 optional = false
 python-versions = ">=3.7"
+groups = ["main", "dev"]
 files = [
     {file = "mdurl-0.1.2-py3-none-any.whl", hash = "sha256:84008a41e51615a49fc9966191ff91509e3c40b939176e643fd50a5c2196b8f8"},
     {file = "mdurl-0.1.2.tar.gz", hash = "sha256:bb413d29f5eea38f31dd4754dd7377d4465116fb207585f97bf925588687c1ba"},
@@ -878,6 +903,7 @@ version = "6.2.0"
 description = "multidict implementation"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "multidict-6.2.0-cp310-cp310-macosx_10_9_universal2.whl", hash = "sha256:b9f6392d98c0bd70676ae41474e2eecf4c7150cb419237a41f8f96043fcb81d1"},
     {file = "multidict-6.2.0-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:3501621d5e86f1a88521ea65d5cad0a0834c77b26f193747615b7c911e5422d2"},
@@ -982,6 +1008,7 @@ version = "1.2.1"
 description = "Parser for multipart/form-data"
 optional = false
 python-versions = ">=3.8"
+groups = ["dev"]
 files = [
     {file = "multipart-1.2.1-py3-none-any.whl", hash = "sha256:c03dc203bc2e67f6b46a599467ae0d87cf71d7530504b2c1ff4a9ea21d8b8c8c"},
     {file = "multipart-1.2.1.tar.gz", hash = "sha256:829b909b67bc1ad1c6d4488fcdc6391c2847842b08323addf5200db88dbe9480"},
@@ -997,6 +1024,7 @@ version = "1.15.0"
 description = "Optional static typing for Python"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "mypy-1.15.0-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:979e4e1a006511dacf628e36fadfecbcc0160a8af6ca7dad2f5025529e082c13"},
     {file = "mypy-1.15.0-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:c4bb0e1bd29f7d34efcccd71cf733580191e9a264a2202b0239da95984c5b559"},
@@ -1050,6 +1078,7 @@ version = "1.0.0"
 description = "Type system extensions for programs checked with the mypy type checker."
 optional = false
 python-versions = ">=3.5"
+groups = ["dev"]
 files = [
     {file = "mypy_extensions-1.0.0-py3-none-any.whl", hash = "sha256:4392f6c0eb8a5668a69e23d168ffa70f0be9ccfd32b5cc2d26a34ae5b844552d"},
     {file = "mypy_extensions-1.0.0.tar.gz", hash = "sha256:75dbf8955dc00442a438fc4d0666508a9a97b6bd41aa2f0ffe9d2f2725af0782"},
@@ -1061,6 +1090,7 @@ version = "2.0.2"
 description = "Fundamental package for array computing in Python"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "numpy-2.0.2-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:51129a29dbe56f9ca83438b706e2e69a39892b5eda6cedcb6b0c9fdc9b0d3ece"},
     {file = "numpy-2.0.2-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:f15975dfec0cf2239224d80e32c3170b1d168335eaedee69da84fbe9f1f9cd04"},
@@ -1115,6 +1145,7 @@ version = "1.69.0"
 description = "The official Python library for the openai API"
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "lint"]
 files = [
     {file = "openai-1.69.0-py3-none-any.whl", hash = "sha256:73c4b2ddfd050060f8d93c70367189bd891e70a5adb6d69c04c3571f4fea5627"},
     {file = "openai-1.69.0.tar.gz", hash = "sha256:7b8a10a8ff77e1ae827e5e4c8480410af2070fb68bc973d6c994cf8218f1f98d"},
@@ -1141,6 +1172,8 @@ version = "0.0.7"
 description = "OpenAI Agents SDK"
 optional = true
 python-versions = ">=3.9"
+groups = ["main"]
+markers = "extra == \"openai-agents\""
 files = [
     {file = "openai_agents-0.0.7-py3-none-any.whl", hash = "sha256:503bbf03ef8b9e47bdcfe65857f4b141daa2b57c1a1a6ed91ed42b76428ab02c"},
     {file = "openai_agents-0.0.7.tar.gz", hash = "sha256:470b3190b070b1a3790cbe62b200dd83d1339602592e90d341aa7bb1af85fa45"},
@@ -1157,66 +1190,70 @@ typing-extensions = ">=4.12.2,<5"
 
 [package.extras]
 viz = ["graphviz (>=0.17)"]
-voice = ["numpy (>=2.2.0,<3)", "websockets (>=15.0,<16)"]
+voice = ["numpy (>=2.2.0,<3) ; python_version >= \"3.10\"", "websockets (>=15.0,<16)"]
 
 [[package]]
 name = "opentelemetry-api"
-version = "1.31.1"
+version = "1.34.1"
 description = "OpenTelemetry Python API"
-optional = true
-python-versions = ">=3.8"
+optional = false
+python-versions = ">=3.9"
+groups = ["main", "dev"]
 files = [
-    {file = "opentelemetry_api-1.31.1-py3-none-any.whl", hash = "sha256:1511a3f470c9c8a32eeea68d4ea37835880c0eed09dd1a0187acc8b1301da0a1"},
-    {file = "opentelemetry_api-1.31.1.tar.gz", hash = "sha256:137ad4b64215f02b3000a0292e077641c8611aab636414632a9b9068593b7e91"},
+    {file = "opentelemetry_api-1.34.1-py3-none-any.whl", hash = "sha256:b7df4cb0830d5a6c29ad0c0691dbae874d8daefa934b8b1d642de48323d32a8c"},
+    {file = "opentelemetry_api-1.34.1.tar.gz", hash = "sha256:64f0bd06d42824843731d05beea88d4d4b6ae59f9fe347ff7dfa2cc14233bbb3"},
 ]
 
 [package.dependencies]
-deprecated = ">=1.2.6"
-importlib-metadata = ">=6.0,<8.7.0"
+importlib-metadata = ">=6.0,<8.8.0"
+typing-extensions = ">=4.5.0"
 
 [[package]]
 name = "opentelemetry-exporter-otlp-proto-common"
-version = "1.31.1"
+version = "1.34.1"
 description = "OpenTelemetry Protobuf encoding"
-optional = true
-python-versions = ">=3.8"
+optional = false
+python-versions = ">=3.9"
+groups = ["main", "dev"]
 files = [
-    {file = "opentelemetry_exporter_otlp_proto_common-1.31.1-py3-none-any.whl", hash = "sha256:7cadf89dbab12e217a33c5d757e67c76dd20ce173f8203e7370c4996f2e9efd8"},
-    {file = "opentelemetry_exporter_otlp_proto_common-1.31.1.tar.gz", hash = "sha256:c748e224c01f13073a2205397ba0e415dcd3be9a0f95101ba4aace5fc730e0da"},
+    {file = "opentelemetry_exporter_otlp_proto_common-1.34.1-py3-none-any.whl", hash = "sha256:8e2019284bf24d3deebbb6c59c71e6eef3307cd88eff8c633e061abba33f7e87"},
+    {file = "opentelemetry_exporter_otlp_proto_common-1.34.1.tar.gz", hash = "sha256:b59a20a927facd5eac06edaf87a07e49f9e4a13db487b7d8a52b37cb87710f8b"},
 ]
 
 [package.dependencies]
-opentelemetry-proto = "1.31.1"
+opentelemetry-proto = "1.34.1"
 
 [[package]]
 name = "opentelemetry-exporter-otlp-proto-http"
-version = "1.31.1"
+version = "1.34.1"
 description = "OpenTelemetry Collector Protobuf over HTTP Exporter"
-optional = true
-python-versions = ">=3.8"
+optional = false
+python-versions = ">=3.9"
+groups = ["main", "dev"]
 files = [
-    {file = "opentelemetry_exporter_otlp_proto_http-1.31.1-py3-none-any.whl", hash = "sha256:5dee1f051f096b13d99706a050c39b08e3f395905f29088bfe59e54218bd1cf4"},
-    {file = "opentelemetry_exporter_otlp_proto_http-1.31.1.tar.gz", hash = "sha256:723bd90eb12cfb9ae24598641cb0c92ca5ba9f1762103902f6ffee3341ba048e"},
+    {file = "opentelemetry_exporter_otlp_proto_http-1.34.1-py3-none-any.whl", hash = "sha256:5251f00ca85872ce50d871f6d3cc89fe203b94c3c14c964bbdc3883366c705d8"},
+    {file = "opentelemetry_exporter_otlp_proto_http-1.34.1.tar.gz", hash = "sha256:aaac36fdce46a8191e604dcf632e1f9380c7d5b356b27b3e0edb5610d9be28ad"},
 ]
 
 [package.dependencies]
-deprecated = ">=1.2.6"
 googleapis-common-protos = ">=1.52,<2.0"
 opentelemetry-api = ">=1.15,<2.0"
-opentelemetry-exporter-otlp-proto-common = "1.31.1"
-opentelemetry-proto = "1.31.1"
-opentelemetry-sdk = ">=1.31.1,<1.32.0"
+opentelemetry-exporter-otlp-proto-common = "1.34.1"
+opentelemetry-proto = "1.34.1"
+opentelemetry-sdk = ">=1.34.1,<1.35.0"
 requests = ">=2.7,<3.0"
+typing-extensions = ">=4.5.0"
 
 [[package]]
 name = "opentelemetry-proto"
-version = "1.31.1"
+version = "1.34.1"
 description = "OpenTelemetry Python Proto"
-optional = true
-python-versions = ">=3.8"
+optional = false
+python-versions = ">=3.9"
+groups = ["main", "dev"]
 files = [
-    {file = "opentelemetry_proto-1.31.1-py3-none-any.whl", hash = "sha256:1398ffc6d850c2f1549ce355744e574c8cd7c1dba3eea900d630d52c41d07178"},
-    {file = "opentelemetry_proto-1.31.1.tar.gz", hash = "sha256:d93e9c2b444e63d1064fb50ae035bcb09e5822274f1683886970d2734208e790"},
+    {file = "opentelemetry_proto-1.34.1-py3-none-any.whl", hash = "sha256:eb4bb5ac27f2562df2d6857fc557b3a481b5e298bc04f94cc68041f00cebcbd2"},
+    {file = "opentelemetry_proto-1.34.1.tar.gz", hash = "sha256:16286214e405c211fc774187f3e4bbb1351290b8dfb88e8948af209ce85b719e"},
 ]
 
 [package.dependencies]
@@ -1224,34 +1261,36 @@ protobuf = ">=5.0,<6.0"
 
 [[package]]
 name = "opentelemetry-sdk"
-version = "1.31.1"
+version = "1.34.1"
 description = "OpenTelemetry Python SDK"
-optional = true
-python-versions = ">=3.8"
+optional = false
+python-versions = ">=3.9"
+groups = ["main", "dev"]
 files = [
-    {file = "opentelemetry_sdk-1.31.1-py3-none-any.whl", hash = "sha256:882d021321f223e37afaca7b4e06c1d8bbc013f9e17ff48a7aa017460a8e7dae"},
-    {file = "opentelemetry_sdk-1.31.1.tar.gz", hash = "sha256:c95f61e74b60769f8ff01ec6ffd3d29684743404603df34b20aa16a49dc8d903"},
+    {file = "opentelemetry_sdk-1.34.1-py3-none-any.whl", hash = "sha256:308effad4059562f1d92163c61c8141df649da24ce361827812c40abb2a1e96e"},
+    {file = "opentelemetry_sdk-1.34.1.tar.gz", hash = "sha256:8091db0d763fcd6098d4781bbc80ff0971f94e260739aa6afe6fd379cdf3aa4d"},
 ]
 
 [package.dependencies]
-opentelemetry-api = "1.31.1"
-opentelemetry-semantic-conventions = "0.52b1"
-typing-extensions = ">=3.7.4"
+opentelemetry-api = "1.34.1"
+opentelemetry-semantic-conventions = "0.55b1"
+typing-extensions = ">=4.5.0"
 
 [[package]]
 name = "opentelemetry-semantic-conventions"
-version = "0.52b1"
+version = "0.55b1"
 description = "OpenTelemetry Semantic Conventions"
-optional = true
-python-versions = ">=3.8"
+optional = false
+python-versions = ">=3.9"
+groups = ["main", "dev"]
 files = [
-    {file = "opentelemetry_semantic_conventions-0.52b1-py3-none-any.whl", hash = "sha256:72b42db327e29ca8bb1b91e8082514ddf3bbf33f32ec088feb09526ade4bc77e"},
-    {file = "opentelemetry_semantic_conventions-0.52b1.tar.gz", hash = "sha256:7b3d226ecf7523c27499758a58b542b48a0ac8d12be03c0488ff8ec60c5bae5d"},
+    {file = "opentelemetry_semantic_conventions-0.55b1-py3-none-any.whl", hash = "sha256:5da81dfdf7d52e3d37f8fe88d5e771e191de924cfff5f550ab0b8f7b2409baed"},
+    {file = "opentelemetry_semantic_conventions-0.55b1.tar.gz", hash = "sha256:ef95b1f009159c28d7a7849f5cbc71c4c34c845bb514d66adfdf1b3fff3598b3"},
 ]
 
 [package.dependencies]
-deprecated = ">=1.2.6"
-opentelemetry-api = "1.31.1"
+opentelemetry-api = "1.34.1"
+typing-extensions = ">=4.5.0"
 
 [[package]]
 name = "orjson"
@@ -1259,6 +1298,8 @@ version = "3.10.16"
 description = "Fast, correct Python JSON library supporting dataclasses, datetimes, and numpy"
 optional = false
 python-versions = ">=3.9"
+groups = ["main"]
+markers = "platform_python_implementation != \"PyPy\""
 files = [
     {file = "orjson-3.10.16-cp310-cp310-macosx_10_15_x86_64.macosx_11_0_arm64.macosx_10_15_universal2.whl", hash = "sha256:4cb473b8e79154fa778fb56d2d73763d977be3dcc140587e07dbc545bbfc38f8"},
     {file = "orjson-3.10.16-cp310-cp310-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:622a8e85eeec1948690409a19ca1c7d9fd8ff116f4861d261e6ae2094fe59a00"},
@@ -1336,10 +1377,12 @@ version = "24.2"
 description = "Core utilities for Python packages"
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev", "test"]
 files = [
     {file = "packaging-24.2-py3-none-any.whl", hash = "sha256:09abb1bccd265c01f4a3aa3f7a7db064b36514d2cba19a2f694fe6150451a759"},
     {file = "packaging-24.2.tar.gz", hash = "sha256:c228a6dc5e932d346bc5739379109d49e8853dd8223571c7c5b55260edc0b97f"},
 ]
+markers = {test = "python_version < \"4.0\""}
 
 [[package]]
 name = "pandas-stubs"
@@ -1347,6 +1390,7 @@ version = "2.2.2.240807"
 description = "Type annotations for pandas"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "pandas_stubs-2.2.2.240807-py3-none-any.whl", hash = "sha256:893919ad82be4275f0d07bb47a95d08bae580d3fdea308a7acfcb3f02e76186e"},
     {file = "pandas_stubs-2.2.2.240807.tar.gz", hash = "sha256:64a559725a57a449f46225fbafc422520b7410bff9252b661a225b5559192a93"},
@@ -1362,6 +1406,7 @@ version = "0.12.1"
 description = "Utility library for gitignore style pattern matching of file paths."
 optional = false
 python-versions = ">=3.8"
+groups = ["dev"]
 files = [
     {file = "pathspec-0.12.1-py3-none-any.whl", hash = "sha256:a0d503e138a4c123b27490a4f7beda6a01c6f288df0e4a8b79c7eb0dc7b4cc08"},
     {file = "pathspec-0.12.1.tar.gz", hash = "sha256:a482d51503a1ab33b1c67a6c3813a26953dbdc71c31dacaef9a838c4e29f5712"},
@@ -1373,6 +1418,7 @@ version = "4.3.7"
 description = "A small Python package for determining appropriate platform-specific dirs, e.g. a `user data dir`."
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "platformdirs-4.3.7-py3-none-any.whl", hash = "sha256:a03875334331946f13c549dbd8f4bac7a13a50a895a0eb1e8c6a8ace80d40a94"},
     {file = "platformdirs-4.3.7.tar.gz", hash = "sha256:eb437d586b6a0986388f0d6f74aa0cde27b48d0e3d66843640bfb6bdcdb6e351"},
@@ -1389,10 +1435,12 @@ version = "1.5.0"
 description = "plugin and hook calling mechanisms for python"
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev", "test"]
 files = [
     {file = "pluggy-1.5.0-py3-none-any.whl", hash = "sha256:44e1ad92c8ca002de6377e165f3e0f1be63266ab4d554740532335b9d75ea669"},
     {file = "pluggy-1.5.0.tar.gz", hash = "sha256:2cffa88e94fdc978c4c574f15f9e59b7f4201d439195c3715ca9e2486f1d0cf1"},
 ]
+markers = {test = "python_version < \"4.0\""}
 
 [package.extras]
 dev = ["pre-commit", "tox"]
@@ -1404,6 +1452,7 @@ version = "0.3.1"
 description = "Accelerated property cache"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "propcache-0.3.1-cp310-cp310-macosx_10_9_universal2.whl", hash = "sha256:f27785888d2fdd918bc36de8b8739f2d6c791399552333721b58193f68ea3e98"},
     {file = "propcache-0.3.1-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:d4e89cde74154c7b5957f87a355bb9c8ec929c167b59c83d90654ea36aeb6180"},
@@ -1509,8 +1558,9 @@ files = [
 name = "protobuf"
 version = "5.29.4"
 description = ""
-optional = true
+optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev"]
 files = [
     {file = "protobuf-5.29.4-cp310-abi3-win32.whl", hash = "sha256:13eb236f8eb9ec34e63fc8b1d6efd2777d062fa6aaa68268fb67cf77f6839ad7"},
     {file = "protobuf-5.29.4-cp310-abi3-win_amd64.whl", hash = "sha256:bcefcdf3976233f8a502d265eb65ea740c989bacc6c30a58290ed0e519eb4b8d"},
@@ -1531,6 +1581,7 @@ version = "5.9.8"
 description = "Cross-platform lib for process and system monitoring in Python."
 optional = false
 python-versions = ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*"
+groups = ["dev"]
 files = [
     {file = "psutil-5.9.8-cp27-cp27m-macosx_10_9_x86_64.whl", hash = "sha256:26bd09967ae00920df88e0352a91cff1a78f8d69b3ecabbfe733610c0af486c8"},
     {file = "psutil-5.9.8-cp27-cp27m-manylinux2010_i686.whl", hash = "sha256:05806de88103b25903dff19bb6692bd2e714ccf9e668d050d144012055cbca73"},
@@ -1551,7 +1602,7 @@ files = [
 ]
 
 [package.extras]
-test = ["enum34", "ipaddress", "mock", "pywin32", "wmi"]
+test = ["enum34 ; python_version <= \"3.4\"", "ipaddress ; python_version < \"3.0\"", "mock ; python_version < \"3.0\"", "pywin32 ; sys_platform == \"win32\"", "wmi ; sys_platform == \"win32\""]
 
 [[package]]
 name = "py-spy"
@@ -1559,6 +1610,7 @@ version = "0.3.14"
 description = "Sampling profiler for Python programs"
 optional = false
 python-versions = "*"
+groups = ["dev"]
 files = [
     {file = "py_spy-0.3.14-py2.py3-none-macosx_10_7_x86_64.whl", hash = "sha256:5b342cc5feb8d160d57a7ff308de153f6be68dcf506ad02b4d67065f2bae7f45"},
     {file = "py_spy-0.3.14-py2.py3-none-macosx_10_9_x86_64.macosx_11_0_arm64.macosx_10_9_universal2.whl", hash = "sha256:fe7efe6c91f723442259d428bf1f9ddb9c1679828866b353d539345ca40d9dd2"},
@@ -1575,6 +1627,8 @@ version = "2.22"
 description = "C parser in Python"
 optional = false
 python-versions = ">=3.8"
+groups = ["main"]
+markers = "platform_python_implementation == \"PyPy\""
 files = [
     {file = "pycparser-2.22-py3-none-any.whl", hash = "sha256:c3702b6d3dd8c7abc1afa565d7e63d53a1d0bd86cdc24edd75470f4de499cfcc"},
     {file = "pycparser-2.22.tar.gz", hash = "sha256:491c8be9c040f5390f5bf44a5b07752bd07f56edf992381b05c701439eec10f6"},
@@ -1586,6 +1640,7 @@ version = "2.11.1"
 description = "Data validation using Python type hints"
 optional = false
 python-versions = ">=3.9"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "pydantic-2.11.1-py3-none-any.whl", hash = "sha256:5b6c415eee9f8123a14d859be0c84363fec6b1feb6b688d6435801230b56e0b8"},
     {file = "pydantic-2.11.1.tar.gz", hash = "sha256:442557d2910e75c991c39f4b4ab18963d57b9b55122c8b2a9cd176d8c29ce968"},
@@ -1599,7 +1654,7 @@ typing-inspection = ">=0.4.0"
 
 [package.extras]
 email = ["email-validator (>=2.0.0)"]
-timezone = ["tzdata"]
+timezone = ["tzdata ; python_version >= \"3.9\" and platform_system == \"Windows\""]
 
 [[package]]
 name = "pydantic-core"
@@ -1607,6 +1662,7 @@ version = "2.33.0"
 description = "Core functionality for Pydantic validation and serialization"
 optional = false
 python-versions = ">=3.9"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "pydantic_core-2.33.0-cp310-cp310-macosx_10_12_x86_64.whl", hash = "sha256:71dffba8fe9ddff628c68f3abd845e91b028361d43c5f8e7b3f8b91d7d85413e"},
     {file = "pydantic_core-2.33.0-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:abaeec1be6ed535a5d7ffc2e6c390083c425832b20efd621562fbb5bff6dc518"},
@@ -1718,6 +1774,8 @@ version = "2.8.1"
 description = "Settings management using Pydantic"
 optional = true
 python-versions = ">=3.8"
+groups = ["main"]
+markers = "python_version >= \"3.10\" and extra == \"openai-agents\""
 files = [
     {file = "pydantic_settings-2.8.1-py3-none-any.whl", hash = "sha256:81942d5ac3d905f7f3ee1a70df5dfb62d5569c12f51a5a647defc1c3d9ee2e9c"},
     {file = "pydantic_settings-2.8.1.tar.gz", hash = "sha256:d5c663dfbe9db9d5e1c646b2e161da12f0d734d422ee56f567d0ea2cee4e8585"},
@@ -1738,6 +1796,7 @@ version = "2.19.1"
 description = "Pygments is a syntax highlighting package written in Python."
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev"]
 files = [
     {file = "pygments-2.19.1-py3-none-any.whl", hash = "sha256:9ea1544ad55cecf4b8242fab6dd35a93bbce657034b0611ee383099054ab6d8c"},
     {file = "pygments-2.19.1.tar.gz", hash = "sha256:61c16d2a8576dc0649d9f39e089b5f02bcd27fba10d8fb4dcc28173f7a45151f"},
@@ -1752,6 +1811,7 @@ version = "2.9.0"
 description = "Python module to run and analyze benchmarks"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "pyperf-2.9.0-py3-none-any.whl", hash = "sha256:215673fb60f3fbbc6c7a90b609b0806d8466fded8dd502bf5731e2b92506076e"},
     {file = "pyperf-2.9.0.tar.gz", hash = "sha256:dbe0feef8ec1a465df191bba2576149762d15a8c9985c9fea93ab625d875c362"},
@@ -1769,10 +1829,12 @@ version = "8.3.5"
 description = "pytest: simple powerful testing with Python"
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev", "test"]
 files = [
     {file = "pytest-8.3.5-py3-none-any.whl", hash = "sha256:c69214aa47deac29fad6c2a4f590b9c4a9fdb16a403176fe154b79c0b4d4d820"},
     {file = "pytest-8.3.5.tar.gz", hash = "sha256:f4efe70cc14e511565ac476b57c279e12a855b11f48f212af1080ef2263d3845"},
 ]
+markers = {test = "python_version < \"4.0\""}
 
 [package.dependencies]
 colorama = {version = "*", markers = "sys_platform == \"win32\""}
@@ -1791,6 +1853,7 @@ version = "0.21.2"
 description = "Pytest support for asyncio"
 optional = false
 python-versions = ">=3.7"
+groups = ["dev"]
 files = [
     {file = "pytest_asyncio-0.21.2-py3-none-any.whl", hash = "sha256:ab664c88bb7998f711d8039cacd4884da6430886ae8bbd4eded552ed2004f16b"},
     {file = "pytest_asyncio-0.21.2.tar.gz", hash = "sha256:d67738fc232b94b326b9d060750beb16e0074210b98dd8b58a5239fa2a154f45"},
@@ -1809,6 +1872,7 @@ version = "4.1.0"
 description = "Pytest plugin for measuring coverage."
 optional = false
 python-versions = ">=3.7"
+groups = ["dev"]
 files = [
     {file = "pytest-cov-4.1.0.tar.gz", hash = "sha256:3904b13dfbfec47f003b8e77fd5b589cd11904a21ddf1ab38a64f204d6a10ef6"},
     {file = "pytest_cov-4.1.0-py3-none-any.whl", hash = "sha256:6ba70b9e97e69fcc3fb45bfeab2d0a138fb65c4d0d6a41ef33983ad114be8c3a"},
@@ -1827,6 +1891,7 @@ version = "0.5.2"
 description = "A py.test plugin that parses environment files before running tests"
 optional = false
 python-versions = "*"
+groups = ["dev"]
 files = [
     {file = "pytest-dotenv-0.5.2.tar.gz", hash = "sha256:2dc6c3ac6d8764c71c6d2804e902d0ff810fa19692e95fe138aefc9b1aa73732"},
     {file = "pytest_dotenv-0.5.2-py3-none-any.whl", hash = "sha256:40a2cece120a213898afaa5407673f6bd924b1fa7eafce6bda0e8abffe2f710f"},
@@ -1842,6 +1907,7 @@ version = "14.0"
 description = "pytest plugin to re-run tests to eliminate flaky failures"
 optional = false
 python-versions = ">=3.8"
+groups = ["dev"]
 files = [
     {file = "pytest-rerunfailures-14.0.tar.gz", hash = "sha256:4a400bcbcd3c7a4ad151ab8afac123d90eca3abe27f98725dc4d9702887d2e92"},
     {file = "pytest_rerunfailures-14.0-py3-none-any.whl", hash = "sha256:4197bdd2eaeffdbf50b5ea6e7236f47ff0e44d1def8dae08e409f536d84e7b32"},
@@ -1857,6 +1923,7 @@ version = "1.7.0"
 description = "Adds the ability to retry flaky tests in CI environments"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "pytest_retry-1.7.0-py3-none-any.whl", hash = "sha256:a2dac85b79a4e2375943f1429479c65beb6c69553e7dae6b8332be47a60954f4"},
     {file = "pytest_retry-1.7.0.tar.gz", hash = "sha256:f8d52339f01e949df47c11ba9ee8d5b362f5824dff580d3870ec9ae0057df80f"},
@@ -1874,6 +1941,8 @@ version = "0.7.0"
 description = "Pytest Plugin to disable socket calls during tests"
 optional = false
 python-versions = ">=3.8,<4.0"
+groups = ["dev", "test"]
+markers = "python_version < \"4.0\""
 files = [
     {file = "pytest_socket-0.7.0-py3-none-any.whl", hash = "sha256:7e0f4642177d55d317bbd58fc68c6bd9048d6eadb2d46a89307fa9221336ce45"},
     {file = "pytest_socket-0.7.0.tar.gz", hash = "sha256:71ab048cbbcb085c15a4423b73b619a8b35d6a307f46f78ea46be51b1b7e11b3"},
@@ -1888,6 +1957,7 @@ version = "0.11.0"
 description = "unittest subTest() support and subtests fixture"
 optional = false
 python-versions = ">=3.7"
+groups = ["dev"]
 files = [
     {file = "pytest-subtests-0.11.0.tar.gz", hash = "sha256:51865c88457545f51fb72011942f0a3c6901ee9e24cbfb6d1b9dc1348bafbe37"},
     {file = "pytest_subtests-0.11.0-py3-none-any.whl", hash = "sha256:453389984952eec85ab0ce0c4f026337153df79587048271c7fd0f49119c07e4"},
@@ -1903,6 +1973,8 @@ version = "0.3.5"
 description = "Automatically rerun your tests on file modifications"
 optional = false
 python-versions = ">=3.7.0,<4.0.0"
+groups = ["dev"]
+markers = "python_version < \"4.0\""
 files = [
     {file = "pytest_watcher-0.3.5-py3-none-any.whl", hash = "sha256:af00ca52c7be22dc34c0fd3d7ffef99057207a73b05dc5161fe3b2fe91f58130"},
     {file = "pytest_watcher-0.3.5.tar.gz", hash = "sha256:8896152460ba2b1a8200c12117c6611008ec96c8b2d811f0a05ab8a82b043ff8"},
@@ -1918,6 +1990,7 @@ version = "3.6.1"
 description = "pytest xdist plugin for distributed testing, most importantly across multiple CPUs"
 optional = false
 python-versions = ">=3.8"
+groups = ["dev"]
 files = [
     {file = "pytest_xdist-3.6.1-py3-none-any.whl", hash = "sha256:9ed4adfb68a016610848639bb7e02c9352d5d9f03d04809919e2dafc3be4cca7"},
     {file = "pytest_xdist-3.6.1.tar.gz", hash = "sha256:ead156a4db231eec769737f57668ef58a2084a34b2e55c4a8fa20d861107300d"},
@@ -1938,6 +2011,7 @@ version = "2.9.0.post0"
 description = "Extensions to the standard Python datetime module"
 optional = false
 python-versions = "!=3.0.*,!=3.1.*,!=3.2.*,>=2.7"
+groups = ["dev"]
 files = [
     {file = "python-dateutil-2.9.0.post0.tar.gz", hash = "sha256:37dd54208da7e1cd875388217d5e00ebd4179249f90fb72437e91a35459a0ad3"},
     {file = "python_dateutil-2.9.0.post0-py2.py3-none-any.whl", hash = "sha256:a8b2bc7bffae282281c8140a97d3aa9c14da0b136dfe83f850eea9a5f7470427"},
@@ -1952,10 +2026,12 @@ version = "1.1.0"
 description = "Read key-value pairs from a .env file and set them as environment variables"
 optional = false
 python-versions = ">=3.9"
+groups = ["main", "dev"]
 files = [
     {file = "python_dotenv-1.1.0-py3-none-any.whl", hash = "sha256:d7c01d9e2293916c18baf562d95698754b0dbbb5e74d457c45d4f6561fb9d55d"},
     {file = "python_dotenv-1.1.0.tar.gz", hash = "sha256:41f90bc6f5f177fb41f53e87666db362025010eb28f60a01c9143bfa33a2b2d5"},
 ]
+markers = {main = "python_version >= \"3.10\" and extra == \"openai-agents\""}
 
 [package.extras]
 cli = ["click (>=5.0)"]
@@ -1966,6 +2042,7 @@ version = "6.0.2"
 description = "YAML parser and emitter for Python"
 optional = false
 python-versions = ">=3.8"
+groups = ["dev"]
 files = [
     {file = "PyYAML-6.0.2-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:0a9a2848a5b7feac301353437eb7d5957887edbf81d56e903999a75a3d743086"},
     {file = "PyYAML-6.0.2-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:29717114e51c84ddfba879543fb232a6ed60086602313ca38cce623c1d62cfbf"},
@@ -2028,6 +2105,7 @@ version = "2.32.3"
 description = "Python HTTP for Humans."
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev"]
 files = [
     {file = "requests-2.32.3-py3-none-any.whl", hash = "sha256:70761cfe03c773ceb22aa2f671b4757976145175cdfca038c02654d061d6dcc6"},
     {file = "requests-2.32.3.tar.gz", hash = "sha256:55365417734eb18255590a9ff9eb97e9e1da868d4ccd6402399eaf68af20a760"},
@@ -2049,6 +2127,7 @@ version = "1.0.0"
 description = "A utility belt for advanced users of python-requests"
 optional = false
 python-versions = ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*"
+groups = ["main"]
 files = [
     {file = "requests-toolbelt-1.0.0.tar.gz", hash = "sha256:7681a0a3d047012b5bdc0ee37d7f8f07ebe76ab08caeccfc3921ce23c88d5bc6"},
     {file = "requests_toolbelt-1.0.0-py2.py3-none-any.whl", hash = "sha256:cccfdd665f0a24fcf4726e690f65639d272bb0637b9b92dfd91a5568ccf6bd06"},
@@ -2063,6 +2142,7 @@ version = "13.9.4"
 description = "Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal"
 optional = false
 python-versions = ">=3.8.0"
+groups = ["main", "dev"]
 files = [
     {file = "rich-13.9.4-py3-none-any.whl", hash = "sha256:6049d5e6ec054bf2779ab3358186963bac2ea89175919d699e378b99738c2a90"},
     {file = "rich-13.9.4.tar.gz", hash = "sha256:439594978a49a09530cff7ebc4b5c7103ef57baf48d5ea3184f21d9a2befa098"},
@@ -2082,6 +2162,7 @@ version = "0.6.9"
 description = "An extremely fast Python linter and code formatter, written in Rust."
 optional = false
 python-versions = ">=3.7"
+groups = ["dev"]
 files = [
     {file = "ruff-0.6.9-py3-none-linux_armv6l.whl", hash = "sha256:064df58d84ccc0ac0fcd63bc3090b251d90e2a372558c0f057c3f75ed73e1ccd"},
     {file = "ruff-0.6.9-py3-none-macosx_10_12_x86_64.whl", hash = "sha256:140d4b5c9f5fc7a7b074908a78ab8d384dd7f6510402267bc76c37195c02a7ec"},
@@ -2109,6 +2190,7 @@ version = "1.17.0"
 description = "Python 2 and 3 compatibility utilities"
 optional = false
 python-versions = "!=3.0.*,!=3.1.*,!=3.2.*,>=2.7"
+groups = ["dev"]
 files = [
     {file = "six-1.17.0-py2.py3-none-any.whl", hash = "sha256:4721f391ed90541fddacab5acf947aa0d3dc7d27b2e1e8eda2be8970586c3274"},
     {file = "six-1.17.0.tar.gz", hash = "sha256:ff70335d468e7eb6ec65b95b99d3a2836546063f63acc5171de367e834932a81"},
@@ -2120,6 +2202,7 @@ version = "1.3.1"
 description = "Sniff out which async library your code is running under"
 optional = false
 python-versions = ">=3.7"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "sniffio-1.3.1-py3-none-any.whl", hash = "sha256:2f6da418d1f1e0fddd844478f41680e794e6051915791a034ff65e5f100525a2"},
     {file = "sniffio-1.3.1.tar.gz", hash = "sha256:f4324edc670a0f49750a81b895f35c3adb843cca46f0530f79fc1babb23789dc"},
@@ -2131,6 +2214,8 @@ version = "2.2.1"
 description = "SSE plugin for Starlette"
 optional = true
 python-versions = ">=3.9"
+groups = ["main"]
+markers = "python_version >= \"3.10\" and extra == \"openai-agents\""
 files = [
     {file = "sse_starlette-2.2.1-py3-none-any.whl", hash = "sha256:6410a3d3ba0c89e7675d4c273a301d64649c03a5ef1ca101f10b47f895fd0e99"},
     {file = "sse_starlette-2.2.1.tar.gz", hash = "sha256:54470d5f19274aeed6b2d473430b08b4b379ea851d953b11d7f1c4a2c118b419"},
@@ -2150,10 +2235,12 @@ version = "0.46.1"
 description = "The little ASGI library that shines."
 optional = false
 python-versions = ">=3.9"
+groups = ["main", "dev"]
 files = [
     {file = "starlette-0.46.1-py3-none-any.whl", hash = "sha256:77c74ed9d2720138b25875133f3a2dae6d854af2ec37dceb56aef370c1d8a227"},
     {file = "starlette-0.46.1.tar.gz", hash = "sha256:3c88d58ee4bd1bb807c0d1acb381838afc7752f9ddaec81bbe4383611d833230"},
 ]
+markers = {main = "python_version >= \"3.10\" and extra == \"openai-agents\""}
 
 [package.dependencies]
 anyio = ">=3.6.2,<5"
@@ -2168,6 +2255,7 @@ version = "2.2.1"
 description = "A lil' TOML parser"
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev", "test"]
 files = [
     {file = "tomli-2.2.1-cp311-cp311-macosx_10_9_x86_64.whl", hash = "sha256:678e4fa69e4575eb77d103de3df8a895e1591b48e740211bd1067378c69e8249"},
     {file = "tomli-2.2.1-cp311-cp311-macosx_11_0_arm64.whl", hash = "sha256:023aa114dd824ade0100497eb2318602af309e5a55595f76b626d6d9f3b7b0a6"},
@@ -2202,6 +2290,7 @@ files = [
     {file = "tomli-2.2.1-py3-none-any.whl", hash = "sha256:cb55c73c5f4408779d0cf3eef9f762b9c9f147a77de7b258bef0a5628adc85cc"},
     {file = "tomli-2.2.1.tar.gz", hash = "sha256:cd45e1dc79c835ce60f7404ec8119f2eb06d38b1deba146f07ced3bbc44505ff"},
 ]
+markers = {main = "python_version < \"3.11\"", dev = "python_full_version <= \"3.11.0a6\"", test = "python_version < \"3.11\""}
 
 [[package]]
 name = "tqdm"
@@ -2209,6 +2298,7 @@ version = "4.67.1"
 description = "Fast, Extensible Progress Meter"
 optional = false
 python-versions = ">=3.7"
+groups = ["main", "lint"]
 files = [
     {file = "tqdm-4.67.1-py3-none-any.whl", hash = "sha256:26445eca388f82e72884e0d580d5464cd801a3ea01e63e5601bdff9ba6a48de2"},
     {file = "tqdm-4.67.1.tar.gz", hash = "sha256:f8aef9c52c08c13a65f30ea34f4e5aac3fd1a34959879d7e59e63027286627f2"},
@@ -2230,6 +2320,7 @@ version = "5.9.5.20240516"
 description = "Typing stubs for psutil"
 optional = false
 python-versions = ">=3.8"
+groups = ["dev"]
 files = [
     {file = "types-psutil-5.9.5.20240516.tar.gz", hash = "sha256:bb296f59fc56458891d0feb1994717e548a1bcf89936a2877df8792b822b4696"},
     {file = "types_psutil-5.9.5.20240516-py3-none-any.whl", hash = "sha256:83146ded949a10167d9895e567b3b71e53ebc5e23fd8363eab62b3c76cce7b89"},
@@ -2241,6 +2332,7 @@ version = "2025.2.0.20250326"
 description = "Typing stubs for pytz"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "types_pytz-2025.2.0.20250326-py3-none-any.whl", hash = "sha256:3c397fd1b845cd2b3adc9398607764ced9e578a98a5d1fbb4a9bc9253edfb162"},
     {file = "types_pytz-2025.2.0.20250326.tar.gz", hash = "sha256:deda02de24f527066fc8d6a19e284ab3f3ae716a42b4adb6b40e75e408c08d36"},
@@ -2252,6 +2344,7 @@ version = "6.0.12.20250326"
 description = "Typing stubs for PyYAML"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "types_pyyaml-6.0.12.20250326-py3-none-any.whl", hash = "sha256:961871cfbdc1ad8ae3cb6ae3f13007262bcfc168adc513119755a6e4d5d7ed65"},
     {file = "types_pyyaml-6.0.12.20250326.tar.gz", hash = "sha256:5e2d86d8706697803f361ba0b8188eef2999e1c372cd4faee4ebb0844b8a4190"},
@@ -2263,6 +2356,8 @@ version = "2.31.0.6"
 description = "Typing stubs for requests"
 optional = false
 python-versions = ">=3.7"
+groups = ["main", "dev"]
+markers = "platform_python_implementation == \"PyPy\" or python_version == \"3.9\""
 files = [
     {file = "types-requests-2.31.0.6.tar.gz", hash = "sha256:cd74ce3b53c461f1228a9b783929ac73a666658f223e28ed29753771477b3bd0"},
     {file = "types_requests-2.31.0.6-py3-none-any.whl", hash = "sha256:a2db9cb228a81da8348b49ad6db3f5519452dd20a9c1e1a868c83c5fe88fd1a9"},
@@ -2277,6 +2372,8 @@ version = "2.32.0.20250328"
 description = "Typing stubs for requests"
 optional = false
 python-versions = ">=3.9"
+groups = ["main", "dev"]
+markers = "platform_python_implementation != \"PyPy\" and python_version >= \"3.10\""
 files = [
     {file = "types_requests-2.32.0.20250328-py3-none-any.whl", hash = "sha256:72ff80f84b15eb3aa7a8e2625fffb6a93f2ad5a0c20215fc1dcfa61117bcb2a2"},
     {file = "types_requests-2.32.0.20250328.tar.gz", hash = "sha256:c9e67228ea103bd811c96984fac36ed2ae8da87a36a633964a21f199d60baf32"},
@@ -2291,6 +2388,7 @@ version = "4.67.0.20250319"
 description = "Typing stubs for tqdm"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "types_tqdm-4.67.0.20250319-py3-none-any.whl", hash = "sha256:8705ef0dd431586e5ea6e010e15b73389b09bcc18186e8c1f530a14dfaa30e09"},
     {file = "types_tqdm-4.67.0.20250319.tar.gz", hash = "sha256:ae947a64bd8d7ed7b7d2b7369df05f9181f847ec2828fdc8a2deb0bb8701adaa"},
@@ -2305,6 +2403,8 @@ version = "1.26.25.14"
 description = "Typing stubs for urllib3"
 optional = false
 python-versions = "*"
+groups = ["main", "dev"]
+markers = "platform_python_implementation == \"PyPy\" or python_version == \"3.9\""
 files = [
     {file = "types-urllib3-1.26.25.14.tar.gz", hash = "sha256:229b7f577c951b8c1b92c1bc2b2fdb0b49847bd2af6d1cc2a2e3dd340f3bda8f"},
     {file = "types_urllib3-1.26.25.14-py3-none-any.whl", hash = "sha256:9683bbb7fb72e32bfe9d2be6e04875fbe1b3eeec3cbb4ea231435aa7fd6b4f0e"},
@@ -2316,6 +2416,7 @@ version = "4.13.0"
 description = "Backported and Experimental Type Hints for Python 3.8+"
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "typing_extensions-4.13.0-py3-none-any.whl", hash = "sha256:c8dd92cc0d6425a97c18fbb9d1954e5ff92c1ca881a309c45f06ebc0b79058e5"},
     {file = "typing_extensions-4.13.0.tar.gz", hash = "sha256:0a4ac55a5820789d87e297727d229866c9650f6521b64206413c4fbada24d95b"},
@@ -2327,6 +2428,8 @@ version = "0.9.0"
 description = "Runtime inspection utilities for typing module."
 optional = false
 python-versions = "*"
+groups = ["dev"]
+markers = "python_version < \"4.0\""
 files = [
     {file = "typing_inspect-0.9.0-py3-none-any.whl", hash = "sha256:9ee6fc59062311ef8547596ab6b955e1b8aa46242d854bfc78f4f6b0eff35f9f"},
     {file = "typing_inspect-0.9.0.tar.gz", hash = "sha256:b23fc42ff6f6ef6954e4852c1fb512cdd18dbea03134f91f856a95ccc9461f78"},
@@ -2342,6 +2445,7 @@ version = "0.4.0"
 description = "Runtime typing introspection tools"
 optional = false
 python-versions = ">=3.9"
+groups = ["main", "dev", "lint", "test"]
 files = [
     {file = "typing_inspection-0.4.0-py3-none-any.whl", hash = "sha256:50e72559fcd2a6367a19f7a7e610e6afcb9fac940c650290eed893d61386832f"},
     {file = "typing_inspection-0.4.0.tar.gz", hash = "sha256:9765c87de36671694a67904bf2c96e395be9c6439bb6c87b5142569dcdd65122"},
@@ -2356,14 +2460,16 @@ version = "1.26.20"
 description = "HTTP library with thread-safe connection pooling, file post, and more."
 optional = false
 python-versions = "!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*,>=2.7"
+groups = ["main", "dev"]
+markers = "platform_python_implementation == \"PyPy\" or python_version == \"3.9\""
 files = [
     {file = "urllib3-1.26.20-py2.py3-none-any.whl", hash = "sha256:0ed14ccfbf1c30a9072c7ca157e4319b70d65f623e91e7b32fadb2853431016e"},
     {file = "urllib3-1.26.20.tar.gz", hash = "sha256:40c2dc0c681e47eb8f90e7e27bf6ff7df2e677421fd46756da1161c39ca70d32"},
 ]
 
 [package.extras]
-brotli = ["brotli (==1.0.9)", "brotli (>=1.0.9)", "brotlicffi (>=0.8.0)", "brotlipy (>=0.6.0)"]
-secure = ["certifi", "cryptography (>=1.3.4)", "idna (>=2.0.0)", "ipaddress", "pyOpenSSL (>=0.14)", "urllib3-secure-extra"]
+brotli = ["brotli (==1.0.9) ; os_name != \"nt\" and python_version < \"3\" and platform_python_implementation == \"CPython\"", "brotli (>=1.0.9) ; python_version >= \"3\" and platform_python_implementation == \"CPython\"", "brotlicffi (>=0.8.0) ; (os_name != \"nt\" or python_version >= \"3\") and platform_python_implementation != \"CPython\"", "brotlipy (>=0.6.0) ; os_name == \"nt\" and python_version < \"3\""]
+secure = ["certifi", "cryptography (>=1.3.4)", "idna (>=2.0.0)", "ipaddress ; python_version == \"2.7\"", "pyOpenSSL (>=0.14)", "urllib3-secure-extra"]
 socks = ["PySocks (>=1.5.6,!=1.5.7,<2.0)"]
 
 [[package]]
@@ -2372,13 +2478,15 @@ version = "2.3.0"
 description = "HTTP library with thread-safe connection pooling, file post, and more."
 optional = false
 python-versions = ">=3.9"
+groups = ["main", "dev"]
+markers = "platform_python_implementation != \"PyPy\" and python_version >= \"3.10\""
 files = [
     {file = "urllib3-2.3.0-py3-none-any.whl", hash = "sha256:1cee9ad369867bfdbbb48b7dd50374c0967a0bb7710050facf0dd6911440e3df"},
     {file = "urllib3-2.3.0.tar.gz", hash = "sha256:f8c5449b3cf0861679ce7e0503c7b44b5ec981bec0d1d3795a07f1ba96f0204d"},
 ]
 
 [package.extras]
-brotli = ["brotli (>=1.0.9)", "brotlicffi (>=0.8.0)"]
+brotli = ["brotli (>=1.0.9) ; platform_python_implementation == \"CPython\"", "brotlicffi (>=0.8.0) ; platform_python_implementation != \"CPython\""]
 h2 = ["h2 (>=4,<5)"]
 socks = ["pysocks (>=1.5.6,!=1.5.7,<2.0)"]
 zstd = ["zstandard (>=0.18.0)"]
@@ -2389,6 +2497,7 @@ version = "0.29.0"
 description = "The lightning-fast ASGI server."
 optional = false
 python-versions = ">=3.8"
+groups = ["main", "dev"]
 files = [
     {file = "uvicorn-0.29.0-py3-none-any.whl", hash = "sha256:2c2aac7ff4f4365c206fd773a39bf4ebd1047c238f8b8268ad996829323473de"},
     {file = "uvicorn-0.29.0.tar.gz", hash = "sha256:6a69214c0b6a087462412670b3ef21224fa48cae0e452b5883e8e8bdfdd11dd0"},
@@ -2400,7 +2509,7 @@ h11 = ">=0.8"
 typing-extensions = {version = ">=4.0", markers = "python_version < \"3.11\""}
 
 [package.extras]
-standard = ["colorama (>=0.4)", "httptools (>=0.5.0)", "python-dotenv (>=0.13)", "pyyaml (>=5.1)", "uvloop (>=0.14.0,!=0.15.0,!=0.15.1)", "watchfiles (>=0.13)", "websockets (>=10.4)"]
+standard = ["colorama (>=0.4) ; sys_platform == \"win32\"", "httptools (>=0.5.0)", "python-dotenv (>=0.13)", "pyyaml (>=5.1)", "uvloop (>=0.14.0,!=0.15.0,!=0.15.1) ; sys_platform != \"win32\" and sys_platform != \"cygwin\" and platform_python_implementation != \"PyPy\"", "watchfiles (>=0.13)", "websockets (>=10.4)"]
 
 [[package]]
 name = "vcrpy"
@@ -2408,6 +2517,7 @@ version = "7.0.0"
 description = "Automatically mock your HTTP interactions to simplify and speed up testing"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "vcrpy-7.0.0-py2.py3-none-any.whl", hash = "sha256:55791e26c18daa363435054d8b35bd41a4ac441b6676167635d1b37a71dbe124"},
     {file = "vcrpy-7.0.0.tar.gz", hash = "sha256:176391ad0425edde1680c5b20738ea3dc7fb942520a48d2993448050986b3a50"},
@@ -2431,6 +2541,8 @@ version = "6.0.0"
 description = "Filesystem events monitoring"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
+markers = "python_version < \"4.0\""
 files = [
     {file = "watchdog-6.0.0-cp310-cp310-macosx_10_9_universal2.whl", hash = "sha256:d1cdb490583ebd691c012b3d6dae011000fe42edb7a82ece80965b42abd61f26"},
     {file = "watchdog-6.0.0-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:bc64ab3bdb6a04d69d4023b29422170b74681784ffb9463ed4870cf2f3e66112"},
@@ -2473,6 +2585,7 @@ version = "1.17.2"
 description = "Module for decorators, wrappers and monkey patching."
 optional = false
 python-versions = ">=3.8"
+groups = ["dev"]
 files = [
     {file = "wrapt-1.17.2-cp310-cp310-macosx_10_9_universal2.whl", hash = "sha256:3d57c572081fed831ad2d26fd430d565b76aa277ed1d30ff4d40670b1c0dd984"},
     {file = "wrapt-1.17.2-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:b5e251054542ae57ac7f3fba5d10bfff615b6c2fb09abeb37d2f1463f841ae22"},
@@ -2561,6 +2674,7 @@ version = "1.18.3"
 description = "Yet another URL library"
 optional = false
 python-versions = ">=3.9"
+groups = ["dev"]
 files = [
     {file = "yarl-1.18.3-cp310-cp310-macosx_10_9_universal2.whl", hash = "sha256:7df647e8edd71f000a5208fe6ff8c382a1de8edfbccdbbfe649d263de07d8c34"},
     {file = "yarl-1.18.3-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:c69697d3adff5aa4f874b19c0e4ed65180ceed6318ec856ebc423aa5850d84f7"},
@@ -2655,19 +2769,20 @@ propcache = ">=0.2.0"
 name = "zipp"
 version = "3.21.0"
 description = "Backport of pathlib-compatible object wrapper for zip files"
-optional = true
+optional = false
 python-versions = ">=3.9"
+groups = ["main", "dev"]
 files = [
     {file = "zipp-3.21.0-py3-none-any.whl", hash = "sha256:ac1bbe05fd2991f160ebce24ffbac5f6d11d83dc90891255885223d42b3cd931"},
     {file = "zipp-3.21.0.tar.gz", hash = "sha256:2c9958f6430a2040341a52eb608ed6dd93ef4392e02ffe219417c1b28b5dd1f4"},
 ]
 
 [package.extras]
-check = ["pytest-checkdocs (>=2.4)", "pytest-ruff (>=0.2.1)"]
+check = ["pytest-checkdocs (>=2.4)", "pytest-ruff (>=0.2.1) ; sys_platform != \"cygwin\""]
 cover = ["pytest-cov"]
 doc = ["furo", "jaraco.packaging (>=9.3)", "jaraco.tidelift (>=1.4)", "rst.linker (>=1.9)", "sphinx (>=3.5)", "sphinx-lint"]
 enabler = ["pytest-enabler (>=2.2)"]
-test = ["big-O", "importlib-resources", "jaraco.functools", "jaraco.itertools", "jaraco.test", "more-itertools", "pytest (>=6,!=8.1.*)", "pytest-ignore-flaky"]
+test = ["big-O", "importlib-resources ; python_version < \"3.9\"", "jaraco.functools", "jaraco.itertools", "jaraco.test", "more-itertools", "pytest (>=6,!=8.1.*)", "pytest-ignore-flaky"]
 type = ["pytest-mypy"]
 
 [[package]]
@@ -2676,6 +2791,7 @@ version = "0.23.0"
 description = "Zstandard bindings for Python"
 optional = false
 python-versions = ">=3.8"
+groups = ["main"]
 files = [
     {file = "zstandard-0.23.0-cp310-cp310-macosx_10_9_x86_64.whl", hash = "sha256:bf0a05b6059c0528477fba9054d09179beb63744355cab9f38059548fedd46a9"},
     {file = "zstandard-0.23.0-cp310-cp310-macosx_11_0_arm64.whl", hash = "sha256:fc9ca1c9718cb3b06634c7c8dec57d24e9438b2aa9a0f02b8bb36bf478538880"},
@@ -2790,6 +2906,6 @@ pytest = ["pytest", "rich"]
 vcr = []
 
 [metadata]
-lock-version = "2.0"
+lock-version = "2.1"
 python-versions = ">=3.9"
-content-hash = "9d28654c653325dbec5add65b46d0ec03b654df3347c2db1dd74d9d026338f4b"
+content-hash = "4c336ba91ce9f87b7fb73b114e27e1adafe7857750e41cd87f0f659fc6822b24"
diff --git a/python/pyproject.toml b/python/pyproject.toml
index f849202a..7dd0909c 100644
--- a/python/pyproject.toml
+++ b/python/pyproject.toml
@@ -78,6 +78,9 @@ httpx = ">=0.23.0,<0.28.0"
 rich = "^13.9.4"
 pytest-retry = "^1.7.0"
 pytest-dotenv = "^0.5.2"
+opentelemetry-sdk = "^1.34.1"
+opentelemetry-exporter-otlp-proto-http = "^1.34.1"
+opentelemetry-api = "^1.34.1"
 
 [tool.poetry.group.lint.dependencies]
 openai = "^1.55"
diff --git a/python/tests/unit_tests/test_hybrid_tracing.py b/python/tests/unit_tests/test_hybrid_tracing.py
index c3d989ab..08e67042 100644
--- a/python/tests/unit_tests/test_hybrid_tracing.py
+++ b/python/tests/unit_tests/test_hybrid_tracing.py
@@ -1,18 +1,34 @@
 """Tests for hybrid OTEL and LangSmith tracing functionality."""
 
+import asyncio
+import importlib
 import os
 import uuid
+from typing import AsyncGenerator, Generator
 from unittest import mock
 from unittest.mock import patch
 
 import pytest
+from opentelemetry.sdk.trace import TracerProvider
+from opentelemetry.trace import (
+    NonRecordingSpan,
+    SpanContext,
+    TraceFlags,
+    TraceState,
+    get_current_span,
+    get_tracer,
+    set_tracer_provider,
+    use_span,
+)
 
-from langsmith import Client
+import langsmith.client
+from langsmith import Client, traceable
 from langsmith._internal._background_thread import (
     TracingQueueItem,
     _hybrid_tracing_thread_handle_batch,
 )
 from langsmith._internal._operations import serialize_run_dict
+from langsmith.utils import get_env_var
 
 
 class MockOTELExporter:
@@ -442,3 +458,604 @@ class TestHybridTracingIntegration:
                 )
 
             mock_session.request.assert_called()
+
+    @patch.dict(
+        os.environ, {"LANGSMITH_OTEL_ENABLED": "true", "LANGSMITH_TRACING": "true"}
+    )
+    def test_otel_context_propagation_with_traceable(self):
+        """Test that OpenTelemetry context is properly set using NonRecordingSpan."""
+        get_env_var.cache_clear()
+
+        tracer_provider = TracerProvider()
+        set_tracer_provider(tracer_provider)
+
+        test_trace_id = 12345678901234567890123456789012345
+        test_span_id = 1234567890123456
+
+        span_context = SpanContext(
+            trace_id=test_trace_id,
+            span_id=test_span_id,
+            is_remote=False,
+            trace_state=TraceState(),
+        )
+        non_recording_span = NonRecordingSpan(span_context)
+
+        captured_span_contexts = []
+
+        def inner_function():
+            current_span = get_current_span()
+            if current_span:
+                captured_span_contexts.append(current_span.get_span_context())
+
+        with use_span(non_recording_span):
+            inner_function()
+
+        assert len(captured_span_contexts) == 1
+        assert captured_span_contexts[0].trace_id == test_trace_id
+        assert captured_span_contexts[0].span_id == test_span_id
+
+        captured_traceable_contexts = []
+
+        @traceable
+        def test_tool():
+            """Test tool that captures the current OpenTelemetry span context."""
+            current_span = get_current_span()
+            if current_span:
+                span_context = current_span.get_span_context()
+                captured_traceable_contexts.append(span_context)
+            return "tool_result"
+
+        result = test_tool()
+
+        assert result == "tool_result"
+
+        assert len(captured_traceable_contexts) >= 1
+
+        span_context = captured_traceable_contexts[0]
+        assert span_context.trace_id > 0
+        assert span_context.span_id > 0
+
+
+def capture_current_context(label: str, captured_contexts: list[tuple[str, int, int]]):
+    current_span = get_current_span()
+    if current_span:
+        context = current_span.get_span_context()
+        captured_contexts.append((label, context.trace_id, context.span_id))
+
+
+class TestOTELContextPropagation:
+    """Test suite for OpenTelemetry context propagation with LangSmith tracing."""
+
+    @patch.dict(
+        os.environ, {"LANGSMITH_OTEL_ENABLED": "true", "LANGSMITH_TRACING": "true"}
+    )
+    def test_nested_langsmith_otel_langsmith_otel_tracing(self):
+        """Test nested tracing pattern: LangSmith -> OTEL -> LangSmith -> OTEL."""
+        get_env_var.cache_clear()
+
+        importlib.reload(langsmith.client)
+
+        from langsmith.client import HAS_OTEL
+
+        assert HAS_OTEL, "HAS_OTEL should be True when OTEL packages are installed"
+
+        tracer_provider = TracerProvider()
+        set_tracer_provider(tracer_provider)
+        tracer = get_tracer(__name__)
+
+        captured_contexts = []
+
+        @traceable
+        def langsmith_outer():
+            capture_current_context("langsmith_outer", captured_contexts)
+
+            with tracer.start_as_current_span("otel_outer"):
+                capture_current_context("otel_outer", captured_contexts)
+
+                @traceable
+                def langsmith_inner():
+                    capture_current_context("langsmith_inner", captured_contexts)
+
+                    with tracer.start_as_current_span("otel_inner"):
+                        capture_current_context("otel_inner", captured_contexts)
+                        return "inner_result"
+
+                return langsmith_inner()
+
+        result = langsmith_outer()
+
+        assert result == "inner_result"
+        assert len(captured_contexts) == 4
+
+        # Verify we captured all contexts
+        labels = [ctx[0] for ctx in captured_contexts]
+        assert "langsmith_outer" in labels
+        assert "otel_outer" in labels
+        assert "langsmith_inner" in labels
+        assert "otel_inner" in labels
+
+        for label, trace_id, span_id in captured_contexts:
+            assert trace_id > 0, f"Invalid trace_id for {label}"
+            assert span_id > 0, f"Invalid span_id for {label}"
+
+        trace_ids = [ctx[1] for ctx in captured_contexts]
+        unique_trace_ids = set(trace_ids)
+        assert (
+            len(unique_trace_ids) == 1
+        ), f"Expected all contexts to share same trace_id, got: {unique_trace_ids}"
+
+    @patch.dict(
+        os.environ, {"LANGSMITH_OTEL_ENABLED": "true", "LANGSMITH_TRACING": "true"}
+    )
+    def test_otel_context_propagation_async(self):
+        """Test OpenTelemetry context propagation with async functions."""
+        get_env_var.cache_clear()
+
+        importlib.reload(langsmith.client)
+
+        from langsmith.client import HAS_OTEL
+
+        assert HAS_OTEL, "HAS_OTEL should be True when OTEL packages are installed"
+
+        tracer_provider = TracerProvider()
+        set_tracer_provider(tracer_provider)
+        tracer = get_tracer(__name__)
+
+        captured_contexts = []
+
+        @traceable
+        async def async_langsmith_outer():
+            """Async LangSmith traced function."""
+            capture_current_context("async_langsmith_outer", captured_contexts)
+
+            with tracer.start_as_current_span("async_otel_outer"):
+                capture_current_context("async_otel_outer", captured_contexts)
+
+                @traceable
+                async def async_langsmith_inner():
+                    """Async inner LangSmith traced function."""
+                    capture_current_context("async_langsmith_inner", captured_contexts)
+
+                    # Simulate async work
+                    await asyncio.sleep(0.01)
+
+                    with tracer.start_as_current_span("async_otel_inner"):
+                        capture_current_context("async_otel_inner", captured_contexts)
+                        await asyncio.sleep(0.01)
+                        return "async_inner_result"
+
+                return await async_langsmith_inner()
+
+        async def run_test():
+            result = await async_langsmith_outer()
+            return result
+
+        # Use asyncio.run to execute the async test
+        result = asyncio.run(run_test())
+
+        assert result == "async_inner_result"
+        assert len(captured_contexts) == 4
+
+        labels = [ctx[0] for ctx in captured_contexts]
+        assert "async_langsmith_outer" in labels
+        assert "async_otel_outer" in labels
+        assert "async_langsmith_inner" in labels
+        assert "async_otel_inner" in labels
+
+        for label, trace_id, span_id in captured_contexts:
+            assert trace_id > 0, f"Invalid trace_id for {label}"
+            assert span_id > 0, f"Invalid span_id for {label}"
+
+        trace_ids = [ctx[1] for ctx in captured_contexts]
+        unique_trace_ids = set(trace_ids)
+        assert len(unique_trace_ids) == 1, (
+            f"Expected all async contexts to share same trace_id, "
+            f"got: {unique_trace_ids}"
+        )
+
+        span_ids = [ctx[2] for ctx in captured_contexts]
+        unique_span_ids = set(span_ids)
+        assert len(unique_span_ids) == len(
+            captured_contexts
+        ), "Each async span should have unique span_id"
+
+    @patch.dict(
+        os.environ, {"LANGSMITH_OTEL_ENABLED": "true", "LANGSMITH_TRACING": "true"}
+    )
+    def test_generator_partial_consumption_with_otel_context(self):
+        """Test OpenTelemetry context propagation with generator partial consumption."""
+        get_env_var.cache_clear()
+
+        # Force reimport of client module to pick up new environment variables
+        importlib.reload(langsmith.client)
+
+        from langsmith.client import HAS_OTEL
+
+        assert HAS_OTEL, "HAS_OTEL should be True when OTEL packages are installed"
+
+        tracer_provider = TracerProvider()
+        set_tracer_provider(tracer_provider)
+        tracer = get_tracer(__name__)
+
+        captured_contexts = []
+        generator_contexts = []
+
+        @traceable
+        def generator_function() -> Generator[str, None, None]:
+            """Generator function that yields values with OTEL context."""
+            capture_current_context("generator_start", captured_contexts)
+
+            with tracer.start_as_current_span("generator_otel_span"):
+                capture_current_context("generator_otel_span", captured_contexts)
+
+                for i in range(5):
+                    current_span = get_current_span()
+                    if current_span:
+                        context = current_span.get_span_context()
+                        generator_contexts.append(
+                            (f"yield_{i}", context.trace_id, context.span_id)
+                        )
+
+                    yield f"value_{i}"
+
+                capture_current_context("generator_end", captured_contexts)
+
+        gen = generator_function()
+
+        value1 = next(gen)
+        value2 = next(gen)
+
+        assert value1 == "value_0"
+        assert value2 == "value_1"
+
+        @traceable
+        def sibling_function():
+            """Sibling function that should have its own context."""
+            capture_current_context("sibling_function", captured_contexts)
+
+            with tracer.start_as_current_span("sibling_otel_span"):
+                capture_current_context("sibling_otel_span", captured_contexts)
+                return "sibling_result"
+
+        sibling_result = sibling_function()
+        assert sibling_result == "sibling_result"
+
+        # Now finish consuming the generator
+        remaining_values = list(gen)
+        assert remaining_values == ["value_2", "value_3", "value_4"]
+
+        assert (
+            len(captured_contexts) >= 4
+        )  # generator_start, generator_otel_span, sibling_function, sibling_otel_span
+        assert len(generator_contexts) == 5
+
+        generator_trace_ids = [ctx[1] for ctx in generator_contexts]
+        assert (
+            len(set(generator_trace_ids)) == 1
+        ), "Generator should maintain same trace ID"
+
+        sibling_contexts = [ctx for ctx in captured_contexts if "sibling" in ctx[0]]
+        assert len(sibling_contexts) == 2
+
+        sibling_trace_ids = [ctx[1] for ctx in sibling_contexts]
+        assert (
+            len(set(sibling_trace_ids)) == 1
+        ), "Sibling should have consistent trace ID"
+
+        generator_trace_id = generator_trace_ids[0]
+        sibling_trace_id = sibling_trace_ids[0]
+        assert (
+            generator_trace_id != sibling_trace_id
+        ), "Generator and sibling should have different trace_ids"
+
+        generator_span_ids = [ctx[2] for ctx in generator_contexts]
+        sibling_span_ids = [ctx[2] for ctx in sibling_contexts]
+        assert (
+            len(set(generator_span_ids)) >= 1
+        ), "Generator should have at least one span"
+        assert len(set(sibling_span_ids)) >= 1, "Sibling should have at least one span"
+
+        for label, trace_id, span_id in captured_contexts + generator_contexts:
+            assert trace_id > 0, f"Invalid trace_id for {label}"
+            assert span_id > 0, f"Invalid span_id for {label}"
+
+    @patch.dict(
+        os.environ, {"LANGSMITH_OTEL_ENABLED": "true", "LANGSMITH_TRACING": "true"}
+    )
+    def test_async_generator_with_otel_context(self):
+        get_env_var.cache_clear()
+
+        tracer_provider = TracerProvider()
+        set_tracer_provider(tracer_provider)
+        tracer = get_tracer(__name__)
+
+        captured_contexts = []
+
+        @traceable
+        async def async_generator_function() -> AsyncGenerator[str, None]:
+            """Async generator function that yields values with OTEL context."""
+            capture_current_context("async_generator_start", captured_contexts)
+
+            with tracer.start_as_current_span("async_generator_otel_span"):
+                capture_current_context("async_generator_otel_span", captured_contexts)
+
+                for i in range(3):
+                    capture_current_context(f"async_yield_{i}", captured_contexts)
+                    await asyncio.sleep(0.01)  # Simulate async work
+                    yield f"async_value_{i}"
+
+                capture_current_context("async_generator_end", captured_contexts)
+
+        async def run_async_generator_test():
+            gen = async_generator_function()
+
+            value1 = await gen.__anext__()
+            assert value1 == "async_value_0"
+
+            @traceable
+            async def async_sibling_function():
+                capture_current_context("async_sibling_function", captured_contexts)
+
+                with tracer.start_as_current_span("async_sibling_otel_span"):
+                    capture_current_context(
+                        "async_sibling_otel_span", captured_contexts
+                    )
+                    await asyncio.sleep(0.01)
+                    return "async_sibling_result"
+
+            sibling_result = await async_sibling_function()
+            assert sibling_result == "async_sibling_result"
+
+            remaining_values = []
+            async for value in gen:
+                remaining_values.append(value)
+
+            assert remaining_values == ["async_value_1", "async_value_2"]
+
+            return True
+
+        result = asyncio.run(run_async_generator_test())
+        assert result is True
+
+        assert len(captured_contexts) >= 6
+
+        generator_contexts = [
+            ctx
+            for ctx in captured_contexts
+            if "async_generator" in ctx[0] or "async_yield" in ctx[0]
+        ]
+        assert len(generator_contexts) >= 4
+
+        sibling_contexts = [
+            ctx for ctx in captured_contexts if "async_sibling" in ctx[0]
+        ]
+        assert len(sibling_contexts) == 2
+
+        for label, trace_id, span_id in captured_contexts:
+            assert trace_id > 0, f"Invalid trace_id for {label}"
+            assert span_id > 0, f"Invalid span_id for {label}"
+
+        generator_trace_ids = [ctx[1] for ctx in generator_contexts]
+        assert (
+            len(set(generator_trace_ids)) == 1
+        ), "Async generator should have consistent trace ID"
+
+        sibling_trace_ids = [ctx[1] for ctx in sibling_contexts]
+        assert (
+            len(set(sibling_trace_ids)) == 1
+        ), "Async sibling should have consistent trace ID"
+
+        generator_trace_id = generator_trace_ids[0]
+        sibling_trace_id = sibling_trace_ids[0]
+        assert (
+            generator_trace_id != sibling_trace_id
+        ), "Async generator and sibling should have different trace_ids"
+
+        generator_span_ids = [ctx[2] for ctx in generator_contexts]
+        sibling_span_ids = [ctx[2] for ctx in sibling_contexts]
+        assert (
+            len(set(generator_span_ids)) >= 1
+        ), "Async generator should have at least one span"
+        assert (
+            len(set(sibling_span_ids)) >= 1
+        ), "Async sibling should have at least one span"
+
+    @patch.dict(
+        os.environ, {"LANGSMITH_OTEL_ENABLED": "true", "LANGSMITH_TRACING": "true"}
+    )
+    def test_complex_nested_context_inheritance(self):
+        """Test complex nested context inheritance patterns."""
+        get_env_var.cache_clear()
+
+        tracer_provider = TracerProvider()
+        set_tracer_provider(tracer_provider)
+        tracer = get_tracer(__name__)
+
+        captured_contexts = []
+
+        test_trace_id = 12345678901234567890123456789012345
+        test_span_id = 1234567890123456
+
+        span_context = SpanContext(
+            trace_id=test_trace_id,
+            span_id=test_span_id,
+            is_remote=False,
+            trace_flags=TraceFlags(TraceFlags.SAMPLED),
+            trace_state=TraceState(),
+        )
+        non_recording_span = NonRecordingSpan(span_context)
+
+        @traceable
+        def langsmith_function_within_existing_otel():
+            """LangSmith function called within existing OTEL context."""
+            capture_current_context("langsmith_within_otel", captured_contexts)
+
+            with tracer.start_as_current_span("nested_otel_span"):
+                capture_current_context(
+                    "nested_otel_within_langsmith", captured_contexts
+                )
+
+                @traceable
+                def deeply_nested_langsmith():
+                    """Deeply nested LangSmith function."""
+                    capture_current_context(
+                        "deeply_nested_langsmith", captured_contexts
+                    )
+                    return "deeply_nested_result"
+
+                return deeply_nested_langsmith()
+
+        # Execute within the pre-existing OTEL context
+        with use_span(non_recording_span):
+            capture_current_context("pre_existing_otel", captured_contexts)
+            result = langsmith_function_within_existing_otel()
+
+        assert result == "deeply_nested_result"
+        assert len(captured_contexts) == 4
+
+        labels = [ctx[0] for ctx in captured_contexts]
+        expected_labels = [
+            "pre_existing_otel",
+            "langsmith_within_otel",
+            "nested_otel_within_langsmith",
+            "deeply_nested_langsmith",
+        ]
+        for label in expected_labels:
+            assert label in labels, f"Missing expected label: {label}"
+
+        pre_existing_context = next(
+            ctx for ctx in captured_contexts if ctx[0] == "pre_existing_otel"
+        )
+        assert pre_existing_context[1] == test_trace_id
+        assert pre_existing_context[2] == test_span_id
+
+        for label, trace_id, span_id in captured_contexts:
+            assert trace_id > 0, f"Invalid trace_id for {label}"
+            assert span_id > 0, f"Invalid span_id for {label}"
+
+        trace_ids = [ctx[1] for ctx in captured_contexts]
+        unique_trace_ids = set(trace_ids)
+
+        assert (
+            test_trace_id in unique_trace_ids
+        ), "Pre-existing OTEL trace_id should be captured"
+
+        pre_existing_traces = [
+            ctx for ctx in captured_contexts if ctx[1] == test_trace_id
+        ]
+        assert (
+            len(pre_existing_traces) >= 1
+        ), "Should capture the pre-existing OTEL context"
+
+        span_ids = [ctx[2] for ctx in captured_contexts]
+        unique_span_ids = set(span_ids)
+        assert len(unique_span_ids) == len(
+            captured_contexts
+        ), "Each span should have unique span_id in nested hierarchy"
+
+    @patch.dict(
+        os.environ, {"LANGSMITH_OTEL_ENABLED": "true", "LANGSMITH_TRACING": "true"}
+    )
+    def test_generator_otel_partial_consumption_with_sibling_traceable(self):
+        """Test the specific scenario: generator with OTEL -> partial consumption ->
+        sibling traceable -> finish consuming generator."""
+        get_env_var.cache_clear()
+
+        tracer_provider = TracerProvider()
+        set_tracer_provider(tracer_provider)
+        tracer = get_tracer(__name__)
+
+        captured_contexts = []
+
+        @traceable
+        def otel_generator_function() -> Generator[str, None, None]:
+            """Generator function that creates OTEL spans and yields values."""
+            capture_current_context("otel_gen_start", captured_contexts)
+
+            with tracer.start_as_current_span("otel_gen_main_span"):
+                capture_current_context("otel_gen_main_span", captured_contexts)
+
+                for i in range(4):
+                    with tracer.start_as_current_span(f"otel_gen_item_{i}"):
+                        capture_current_context(
+                            f"otel_gen_before_yield_{i}", captured_contexts
+                        )
+                        yield f"otel_value_{i}"
+                        capture_current_context(
+                            f"otel_gen_after_yield_{i}", captured_contexts
+                        )
+
+                capture_current_context("otel_gen_end", captured_contexts)
+
+        otel_gen = otel_generator_function()
+
+        value1 = next(otel_gen)
+        value2 = next(otel_gen)
+
+        assert value1 == "otel_value_0"
+        assert value2 == "otel_value_1"
+
+        @traceable
+        def sibling_traceable_function():
+            capture_current_context("sibling_start", captured_contexts)
+
+            with tracer.start_as_current_span("sibling_otel_span"):
+                capture_current_context("sibling_otel_span", captured_contexts)
+
+                result = "sibling_work_done"
+                capture_current_context("sibling_before_return", captured_contexts)
+                return result
+
+        sibling_result = sibling_traceable_function()
+        assert sibling_result == "sibling_work_done"
+
+        remaining_values = list(otel_gen)
+
+        assert remaining_values == ["otel_value_2", "otel_value_3"]
+
+        generator_contexts = [ctx for ctx in captured_contexts if "otel_gen" in ctx[0]]
+        sibling_contexts = [ctx for ctx in captured_contexts if "sibling" in ctx[0]]
+
+        assert len(generator_contexts) >= 10
+        assert len(sibling_contexts) == 3
+
+        generator_trace_ids = [ctx[1] for ctx in generator_contexts]
+        unique_generator_trace_ids = set(generator_trace_ids)
+        assert len(unique_generator_trace_ids) == 1, (
+            f"Generator should have consistent trace_id, "
+            f"got: {unique_generator_trace_ids}"
+        )
+
+        sibling_trace_ids = [ctx[1] for ctx in sibling_contexts]
+        unique_sibling_trace_ids = set(sibling_trace_ids)
+        assert (
+            len(unique_sibling_trace_ids) == 1
+        ), f"Sibling should have consistent trace_id, got: {unique_sibling_trace_ids}"
+
+        generator_trace_id = generator_trace_ids[0]
+        sibling_trace_id = sibling_trace_ids[0]
+        assert (
+            generator_trace_id != sibling_trace_id
+        ), "Generator and sibling should have different trace_ids"
+
+        contexts_before_sibling = [
+            ctx
+            for ctx in generator_contexts
+            if "yield_0" in ctx[0] or "yield_1" in ctx[0]
+        ]
+        contexts_after_sibling = [
+            ctx
+            for ctx in generator_contexts
+            if "yield_2" in ctx[0] or "yield_3" in ctx[0]
+        ]
+
+        before_trace_ids = [ctx[1] for ctx in contexts_before_sibling]
+        after_trace_ids = [ctx[1] for ctx in contexts_after_sibling]
+
+        assert set(before_trace_ids) == set(
+            after_trace_ids
+        ), "Generator trace should be consistent before and after sibling"
+
+        for label, trace_id, span_id in captured_contexts:
+            assert trace_id > 0, f"Invalid trace_id for {label}"
+            assert span_id > 0, f"Invalid span_id for {label}"
